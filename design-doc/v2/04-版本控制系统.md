# 版本控制系统

## 文档信息

| 字段 | 值 |
|------|-----|
| 版本 | v2.0 |
| 日期 | 2026-02-17 |
| 优先级 | P2 |
| 关联模块 | 03-Beta-Reader, 05-稿件导出 |

---

## 1. 背景与动机

### 1.1 问题陈述

当前 v1 版本的 AINovel 系统在稿件管理方面存在严重缺陷：

1. **编辑即覆盖，无法回溯**：`Manuscript` 实体的 `sectionsJson` 字段直接存储所有场景正文。每次调用 `ManuscriptService.updateSection()` 都会原地覆盖 `sectionsJson`，没有任何历史记录。一旦保存，旧版本永久丢失。

2. **无法对比版本差异**：作者在反复修改某个场景后，无法查看"改了什么"。前端 `ManuscriptWriter.tsx` 中的"历史版本"按钮（`<History />` 图标）目前是空操作，没有后端支持。

3. **无法分支探索**：长篇小说创作中，作者经常需要尝试不同的情节走向——例如"如果主角在第5章选择了另一条路"。当前系统不支持分支，作者只能手动复制粘贴到外部文档，极易混乱。

4. **自动保存无快照**：前端 `scheduleSave()` 每 1200ms 防抖后自动保存，但后端只是覆盖写入。高频自动保存反而加速了历史丢失。

5. **协作风险**：未来如果支持多人协作，没有版本控制将导致冲突无法追踪和解决。

### 1.2 业界参考

| 产品/技术 | 核心机制 | 借鉴点 |
|-----------|----------|--------|
| **Google Docs 版本历史** | 自动保存 + 命名版本，支持任意时间点回溯，按时间线展示修改历史 | 自动快照策略、时间线 UI、版本命名机制 |
| **Git 分支模型** | 基于 DAG 的版本图，支持分支、合并、冲突检测，内容寻址存储 | 分支/合并概念模型、SHA 内容哈希、parent 链式结构 |
| **Scrivener Snapshots** | 手动快照 + 自动编译前快照，每个文档独立快照，支持快照对比 | 手动检查点概念、文档级粒度、快照对比 UI |
| **Notion 页面历史** | 自动版本记录，30天历史保留，支持逐版本回溯 | 自动版本策略、存储保留策略、简洁回溯 UI |
| **Ulysses 版本管理** | iCloud 版本流，支持浏览和恢复任意历史版本 | 轻量级版本浏览体验 |

---

## 2. 设计目标

1. **自动快照**：每次保存时自动创建版本快照，支持可配置的快照间隔（默认 300 秒内的多次保存合并为一个快照），避免快照爆炸。

2. **手动检查点**：作者可随时创建命名检查点（如"第三章定稿"、"大战前夕版本"），作为重要里程碑标记。

3. **完整差异对比**：支持任意两个版本之间的 diff 对比，提供逐行差异、并排对比和统一对比三种视图模式，支持按场景粒度选择对比范围。

4. **分支支持**：支持从任意版本创建分支，用于探索替代情节线。每个稿件默认有一个 `main` 分支，作者可创建任意数量的命名分支。

5. **分支合并**：支持将分支合并回主线，提供冲突检测和解决 UI。支持"整体替换"和"逐场景选择"两种合并策略。

6. **版本回滚**：支持一键回滚到任意历史版本，回滚操作本身也会创建一个新版本（不破坏历史链）。

7. **场景级粒度**：版本快照以完整 `sectionsJson` 为单位存储，但 diff 对比和合并操作支持按单个场景（scene）粒度进行。

8. **存储可控**：自动快照有数量上限（默认 100），超出后按 FIFO 清理最旧的自动快照（手动检查点不受此限制）。

---

## 3. 详细设计

### 3.1 数据模型

#### 3.1.1 表 1：`manuscript_versions` — 稿件版本表

存储稿件的每一个版本快照，包括自动快照、手动检查点、分支点和合并点。

```sql
CREATE TABLE manuscript_versions (
    id                  CHAR(36)        NOT NULL    COMMENT '主键 UUID',
    manuscript_id       CHAR(36)        NOT NULL    COMMENT '所属稿件 FK -> manuscripts.id',
    branch_id           CHAR(36)        NOT NULL    COMMENT '所属分支 FK -> manuscript_branches.id',
    version_number      INT             NOT NULL    COMMENT '版本序号（分支内递增）',
    label               VARCHAR(200)    NULL        COMMENT '用户自定义标签，如"第三章定稿"',
    snapshot_type       ENUM('auto','manual','branch_point','merge')
                                        NOT NULL DEFAULT 'auto'
                                                    COMMENT '快照类型',
    content_hash        VARCHAR(64)     NOT NULL    COMMENT 'sectionsJson 的 SHA-256 哈希，用于去重',
    sections_json       LONGTEXT        NOT NULL    COMMENT '完整的 sectionsJson 快照（sceneId -> content）',
    metadata_json       TEXT            NULL        COMMENT '版本元数据 JSON: {"word_count":12345,"chapter_count":5,"scene_count":18}',
    parent_version_id   CHAR(36)        NULL        COMMENT '父版本 FK -> manuscript_versions.id（自引用）',
    created_by          CHAR(36)        NOT NULL    COMMENT '创建用户 FK -> users.id',
    created_at          TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (id),
    INDEX idx_version_manuscript (manuscript_id),
    INDEX idx_version_branch (branch_id),
    INDEX idx_version_manuscript_branch (manuscript_id, branch_id, version_number),
    INDEX idx_version_parent (parent_version_id),
    INDEX idx_version_hash (manuscript_id, content_hash),
    INDEX idx_version_type (manuscript_id, snapshot_type),
    INDEX idx_version_created (manuscript_id, created_at),
    CONSTRAINT fk_version_manuscript FOREIGN KEY (manuscript_id) REFERENCES manuscripts(id) ON DELETE CASCADE,
    CONSTRAINT fk_version_branch    FOREIGN KEY (branch_id)     REFERENCES manuscript_branches(id) ON DELETE CASCADE,
    CONSTRAINT fk_version_parent    FOREIGN KEY (parent_version_id) REFERENCES manuscript_versions(id) ON DELETE SET NULL,
    CONSTRAINT fk_version_user      FOREIGN KEY (created_by)    REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  COMMENT='稿件版本快照表';
```

#### 3.1.2 表 2：`manuscript_branches` — 稿件分支表

管理稿件的分支信息，每个稿件默认有一个 `main` 分支。

```sql
CREATE TABLE manuscript_branches (
    id                  CHAR(36)        NOT NULL    COMMENT '主键 UUID',
    manuscript_id       CHAR(36)        NOT NULL    COMMENT '所属稿件 FK -> manuscripts.id',
    name                VARCHAR(100)    NOT NULL    COMMENT '分支名称，如 "main"、"暗线-复仇路线"',
    description         TEXT            NULL        COMMENT '分支描述，说明该分支的探索方向',
    source_version_id   CHAR(36)        NULL        COMMENT '分支起点版本 FK -> manuscript_versions.id',
    status              ENUM('active','merged','abandoned')
                                        NOT NULL DEFAULT 'active'
                                                    COMMENT '分支状态',
    is_main             TINYINT(1)      NOT NULL DEFAULT 0
                                                    COMMENT '是否为主分支（每个稿件仅一个）',
    created_at          TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at          TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    PRIMARY KEY (id),
    INDEX idx_branch_manuscript (manuscript_id),
    INDEX idx_branch_status (manuscript_id, status),
    UNIQUE INDEX uk_branch_name (manuscript_id, name),
    CONSTRAINT fk_branch_manuscript FOREIGN KEY (manuscript_id) REFERENCES manuscripts(id) ON DELETE CASCADE,
    CONSTRAINT fk_branch_source     FOREIGN KEY (source_version_id) REFERENCES manuscript_versions(id) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  COMMENT='稿件分支表';
```

#### 3.1.3 表 3：`version_diffs` — 版本差异缓存表

缓存已计算的版本差异结果，避免重复计算。

```sql
CREATE TABLE version_diffs (
    id                  CHAR(36)        NOT NULL    COMMENT '主键 UUID',
    from_version_id     CHAR(36)        NOT NULL    COMMENT '起始版本 FK -> manuscript_versions.id',
    to_version_id       CHAR(36)        NOT NULL    COMMENT '目标版本 FK -> manuscript_versions.id',
    diff_json           LONGTEXT        NOT NULL    COMMENT '预计算的差异结果 JSON',
    created_at          TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (id),
    UNIQUE INDEX uk_diff_pair (from_version_id, to_version_id),
    CONSTRAINT fk_diff_from FOREIGN KEY (from_version_id) REFERENCES manuscript_versions(id) ON DELETE CASCADE,
    CONSTRAINT fk_diff_to   FOREIGN KEY (to_version_id)   REFERENCES manuscript_versions(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  COMMENT='版本差异缓存表';
```

#### 3.1.4 表 4：`auto_save_config` — 自动保存配置表

存储用户级别的自动保存偏好设置。

```sql
CREATE TABLE auto_save_config (
    id                          CHAR(36)    NOT NULL    COMMENT '主键 UUID',
    user_id                     CHAR(36)    NOT NULL    COMMENT '用户 FK -> users.id',
    auto_save_interval_seconds  INT         NOT NULL DEFAULT 300
                                                        COMMENT '自动快照最小间隔（秒），同一间隔内多次保存只生成一个快照',
    max_auto_versions           INT         NOT NULL DEFAULT 100
                                                        COMMENT '每个稿件每个分支的自动快照上限',
    created_at                  TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at                  TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    PRIMARY KEY (id),
    UNIQUE INDEX uk_config_user (user_id),
    CONSTRAINT fk_config_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  COMMENT='用户自动保存配置表';
```

#### 3.1.5 ER 关系图

```
manuscripts (1) ──────< manuscript_branches (N)
    │                        │
    │                        │ source_version_id
    │                        ▼
    └──────────────< manuscript_versions (N)
                         │         │
                         │         │ parent_version_id (self-ref)
                         │         └──────> manuscript_versions
                         │
                         └──────< version_diffs (N:from/to)

users (1) ──────< auto_save_config (1)
users (1) ──────< manuscript_versions (N:created_by)
```

#### 3.1.6 现有表变更

`manuscripts` 表新增字段：

```sql
ALTER TABLE manuscripts
    ADD COLUMN current_branch_id CHAR(36) NULL COMMENT '当前活跃分支 FK -> manuscript_branches.id'
        AFTER character_logs_json,
    ADD CONSTRAINT fk_manuscript_current_branch
        FOREIGN KEY (current_branch_id) REFERENCES manuscript_branches(id)
        ON DELETE SET NULL;
```

---

### 3.2 后端设计

#### 3.2.1 包结构

```
backend/src/main/java/com/ainovel/app/version/
├── VersionController.java          // REST API 控制器
├── VersionService.java             // 版本核心操作（快照、回滚）
├── BranchService.java              // 分支管理（创建、合并、废弃）
├── DiffService.java                // 差异计算（基于 java-diff-utils）
├── AutoSaveService.java            // 自动快照调度
├── dto/
│   ├── VersionDto.java             // 版本响应 DTO
│   ├── VersionListResponse.java    // 分页版本列表
│   ├── CreateSnapshotRequest.java  // 手动快照请求
│   ├── RollbackRequest.java        // 回滚请求
│   ├── DiffResult.java             // 差异计算结果
│   ├── SceneDiff.java              // 单场景差异
│   ├── BranchDto.java              // 分支响应 DTO
│   ├── CreateBranchRequest.java    // 创建分支请求
│   ├── MergeBranchRequest.java     // 合并分支请求
│   ├── MergeResult.java            // 合并结果
│   └── AutoSaveConfigDto.java      // 自动保存配置 DTO
├── model/
│   ├── ManuscriptVersion.java      // 版本实体
│   ├── ManuscriptBranch.java       // 分支实体
│   ├── VersionDiff.java            // 差异缓存实体
│   ├── AutoSaveConfig.java         // 自动保存配置实体
│   └── enums/
│       ├── SnapshotType.java       // ENUM: auto, manual, branch_point, merge
│       ├── BranchStatus.java       // ENUM: active, merged, abandoned
│       └── MergeStrategy.java      // ENUM: replace_all, per_scene_select
└── repo/
    ├── VersionRepository.java      // 版本 JPA Repository
    ├── BranchRepository.java       // 分支 JPA Repository
    ├── VersionDiffRepository.java  // 差异缓存 Repository
    └── AutoSaveConfigRepository.java
```

#### 3.2.2 核心类设计

##### VersionService — 版本核心操作

```java
@Service
public class VersionService {

    @Autowired private VersionRepository versionRepository;
    @Autowired private BranchRepository branchRepository;
    @Autowired private ManuscriptRepository manuscriptRepository;
    @Autowired private ObjectMapper objectMapper;

    /**
     * 创建版本快照。
     * 1. 读取当前 manuscript.sectionsJson
     * 2. 计算 SHA-256 哈希，若与最新版本哈希相同则跳过（内容未变）
     * 3. 查找当前分支的最新版本作为 parent
     * 4. 计算 metadata（字数、章节数、场景数）
     * 5. 持久化 ManuscriptVersion
     * 6. 若为自动快照，检查是否超出 max_auto_versions 上限并清理
     */
    @Transactional
    public ManuscriptVersion createSnapshot(UUID manuscriptId, String label,
                                            SnapshotType type, UUID userId) {
        Manuscript manuscript = manuscriptRepository.findById(manuscriptId)
            .orElseThrow(() -> new RuntimeException("稿件不存在"));

        UUID branchId = manuscript.getCurrentBranchId();
        String sectionsJson = manuscript.getSectionsJson();
        String contentHash = DigestUtils.sha256Hex(sectionsJson);

        // 去重：内容未变则跳过
        Optional<ManuscriptVersion> latest = versionRepository
            .findTopByBranchIdOrderByVersionNumberDesc(branchId);
        if (latest.isPresent() && latest.get().getContentHash().equals(contentHash)) {
            return latest.get(); // 内容未变，返回现有版本
        }

        int nextVersionNumber = latest.map(v -> v.getVersionNumber() + 1).orElse(1);

        ManuscriptVersion version = new ManuscriptVersion();
        version.setManuscriptId(manuscriptId);
        version.setBranchId(branchId);
        version.setVersionNumber(nextVersionNumber);
        version.setLabel(label);
        version.setSnapshotType(type);
        version.setContentHash(contentHash);
        version.setSectionsJson(sectionsJson);
        version.setMetadataJson(computeMetadata(sectionsJson));
        version.setParentVersionId(latest.map(ManuscriptVersion::getId).orElse(null));
        version.setCreatedBy(userId);

        versionRepository.save(version);

        // 自动快照清理
        if (type == SnapshotType.AUTO) {
            cleanupAutoVersions(manuscriptId, branchId, userId);
        }

        return version;
    }

    /**
     * 回滚到指定版本。
     * 1. 读取目标版本的 sectionsJson
     * 2. 先创建一个当前状态的快照（标记为 manual，label="回滚前自动备份"）
     * 3. 将目标版本的 sectionsJson 写入 manuscript
     * 4. 创建一个新版本（标记为 manual，label="回滚至 v{N}"）
     * 回滚不破坏历史链，而是在链尾追加新版本。
     */
    @Transactional
    public Manuscript rollback(UUID manuscriptId, UUID versionId, UUID userId) {
        ManuscriptVersion targetVersion = versionRepository.findById(versionId)
            .orElseThrow(() -> new RuntimeException("版本不存在"));
        Manuscript manuscript = manuscriptRepository.findById(manuscriptId)
            .orElseThrow(() -> new RuntimeException("稿件不存在"));

        // 先备份当前状态
        createSnapshot(manuscriptId, "回滚前自动备份", SnapshotType.MANUAL, userId);

        // 恢复目标版本内容
        manuscript.setSectionsJson(targetVersion.getSectionsJson());
        manuscriptRepository.save(manuscript);

        // 创建回滚版本记录
        createSnapshot(manuscriptId,
            "回滚至 v" + targetVersion.getVersionNumber(),
            SnapshotType.MANUAL, userId);

        return manuscript;
    }

    // ... 辅助方法省略
}
```

##### DiffService — 差异计算

基于 `io.github.java-diff-utils:java-diff-utils` 实现逐场景的文本差异计算。

```java
@Service
public class DiffService {

    @Autowired private VersionRepository versionRepository;
    @Autowired private VersionDiffRepository diffRepository;
    @Autowired private ObjectMapper objectMapper;

    /**
     * 计算两个版本之间的差异。
     * 1. 先查缓存表 version_diffs
     * 2. 若无缓存，解析两个版本的 sectionsJson
     * 3. 对每个 sceneId 分别计算 diff
     * 4. 汇总为 DiffResult 并缓存
     */
    public DiffResult computeDiff(UUID fromVersionId, UUID toVersionId) {
        // 查缓存
        Optional<VersionDiff> cached = diffRepository
            .findByFromVersionIdAndToVersionId(fromVersionId, toVersionId);
        if (cached.isPresent()) {
            return parseDiffJson(cached.get().getDiffJson());
        }

        ManuscriptVersion fromVersion = versionRepository.findById(fromVersionId)
            .orElseThrow(() -> new RuntimeException("起始版本不存在"));
        ManuscriptVersion toVersion = versionRepository.findById(toVersionId)
            .orElseThrow(() -> new RuntimeException("目标版本不存在"));

        Map<String, String> fromSections = parseSectionsJson(fromVersion.getSectionsJson());
        Map<String, String> toSections = parseSectionsJson(toVersion.getSectionsJson());

        // 收集所有 sceneId
        Set<String> allSceneIds = new LinkedHashSet<>();
        allSceneIds.addAll(fromSections.keySet());
        allSceneIds.addAll(toSections.keySet());

        List<SceneDiff> sceneDiffs = new ArrayList<>();
        int totalAdded = 0, totalRemoved = 0, totalChanged = 0;

        for (String sceneId : allSceneIds) {
            String fromText = fromSections.getOrDefault(sceneId, "");
            String toText = toSections.getOrDefault(sceneId, "");

            if (fromText.equals(toText)) continue; // 无变化，跳过

            // 使用 java-diff-utils 计算行级差异
            List<String> fromLines = Arrays.asList(fromText.split("\n"));
            List<String> toLines = Arrays.asList(toText.split("\n"));
            Patch<String> patch = DiffUtils.diff(fromLines, toLines);

            SceneDiff sceneDiff = new SceneDiff();
            sceneDiff.setSceneId(sceneId);
            sceneDiff.setChangeType(determineChangeType(fromText, toText));
            sceneDiff.setDeltas(convertDeltas(patch.getDeltas()));
            sceneDiff.setAddedLines(countAddedLines(patch));
            sceneDiff.setRemovedLines(countRemovedLines(patch));

            sceneDiffs.add(sceneDiff);
            totalAdded += sceneDiff.getAddedLines();
            totalRemoved += sceneDiff.getRemovedLines();
            totalChanged++;
        }

        DiffResult result = new DiffResult();
        result.setFromVersionId(fromVersionId);
        result.setToVersionId(toVersionId);
        result.setSceneDiffs(sceneDiffs);
        result.setTotalScenesChanged(totalChanged);
        result.setTotalLinesAdded(totalAdded);
        result.setTotalLinesRemoved(totalRemoved);

        // 写入缓存
        saveDiffCache(fromVersionId, toVersionId, result);

        return result;
    }
}
```

`DiffResult` 数据结构：

```java
public record DiffResult(
    UUID fromVersionId,
    UUID toVersionId,
    List<SceneDiff> sceneDiffs,
    int totalScenesChanged,
    int totalLinesAdded,
    int totalLinesRemoved
) {}

public record SceneDiff(
    String sceneId,
    String changeType,    // "added" | "removed" | "modified"
    List<DeltaDto> deltas,
    int addedLines,
    int removedLines
) {}

public record DeltaDto(
    String type,          // "INSERT" | "DELETE" | "CHANGE"
    int sourcePosition,
    List<String> sourceLines,
    int targetPosition,
    List<String> targetLines
) {}
```

##### BranchService — 分支管理

```java
@Service
public class BranchService {

    @Autowired private BranchRepository branchRepository;
    @Autowired private VersionRepository versionRepository;
    @Autowired private ManuscriptRepository manuscriptRepository;
    @Autowired private VersionService versionService;
    @Autowired private ObjectMapper objectMapper;

    /**
     * 初始化稿件的主分支。在稿件首次创建时调用。
     */
    @Transactional
    public ManuscriptBranch initMainBranch(UUID manuscriptId) {
        ManuscriptBranch main = new ManuscriptBranch();
        main.setManuscriptId(manuscriptId);
        main.setName("main");
        main.setDescription("主线");
        main.setIsMain(true);
        main.setStatus(BranchStatus.ACTIVE);
        branchRepository.save(main);

        // 更新稿件的当前分支
        Manuscript manuscript = manuscriptRepository.findById(manuscriptId).orElseThrow();
        manuscript.setCurrentBranchId(main.getId());
        manuscriptRepository.save(manuscript);

        return main;
    }

    /**
     * 从指定版本创建新分支。
     * 1. 创建 ManuscriptBranch 记录
     * 2. 在新分支上创建初始版本（复制源版本的 sectionsJson）
     * 3. 标记源版本为 branch_point 类型
     */
    @Transactional
    public ManuscriptBranch createBranch(UUID manuscriptId, UUID fromVersionId,
                                         String name, String description, UUID userId) {
        // 校验分支名唯一
        if (branchRepository.existsByManuscriptIdAndName(manuscriptId, name)) {
            throw new RuntimeException("分支名称已存在: " + name);
        }

        ManuscriptVersion sourceVersion = versionRepository.findById(fromVersionId)
            .orElseThrow(() -> new RuntimeException("源版本不存在"));

        ManuscriptBranch branch = new ManuscriptBranch();
        branch.setManuscriptId(manuscriptId);
        branch.setName(name);
        branch.setDescription(description);
        branch.setSourceVersionId(fromVersionId);
        branch.setStatus(BranchStatus.ACTIVE);
        branch.setIsMain(false);
        branchRepository.save(branch);

        // 在新分支上创建初始版本
        ManuscriptVersion branchVersion = new ManuscriptVersion();
        branchVersion.setManuscriptId(manuscriptId);
        branchVersion.setBranchId(branch.getId());
        branchVersion.setVersionNumber(1);
        branchVersion.setLabel("从 v" + sourceVersion.getVersionNumber() + " 分支");
        branchVersion.setSnapshotType(SnapshotType.BRANCH_POINT);
        branchVersion.setContentHash(sourceVersion.getContentHash());
        branchVersion.setSectionsJson(sourceVersion.getSectionsJson());
        branchVersion.setMetadataJson(sourceVersion.getMetadataJson());
        branchVersion.setParentVersionId(fromVersionId);
        branchVersion.setCreatedBy(userId);
        versionRepository.save(branchVersion);

        return branch;
    }

    /**
     * 合并分支到主线。
     * 策略一 REPLACE_ALL：用分支最新版本整体替换主线内容。
     * 策略二 PER_SCENE_SELECT：逐场景选择保留主线或分支版本（需前端传入选择映射）。
     * 合并后在主线创建一个 merge 类型的版本，分支状态标记为 merged。
     */
    @Transactional
    public MergeResult mergeBranch(UUID branchId, MergeStrategy strategy,
                                   Map<String, String> sceneSelections, UUID userId) {
        ManuscriptBranch branch = branchRepository.findById(branchId)
            .orElseThrow(() -> new RuntimeException("分支不存在"));

        if (branch.getIsMain()) {
            throw new RuntimeException("不能合并主分支到自身");
        }

        UUID manuscriptId = branch.getManuscriptId();
        ManuscriptBranch mainBranch = branchRepository
            .findByManuscriptIdAndIsMainTrue(manuscriptId)
            .orElseThrow(() -> new RuntimeException("主分支不存在"));

        ManuscriptVersion branchLatest = versionRepository
            .findTopByBranchIdOrderByVersionNumberDesc(branch.getId())
            .orElseThrow(() -> new RuntimeException("分支无版本"));
        ManuscriptVersion mainLatest = versionRepository
            .findTopByBranchIdOrderByVersionNumberDesc(mainBranch.getId())
            .orElseThrow(() -> new RuntimeException("主线无版本"));

        String mergedSectionsJson;
        List<String> conflicts = new ArrayList<>();

        if (strategy == MergeStrategy.REPLACE_ALL) {
            mergedSectionsJson = branchLatest.getSectionsJson();
        } else {
            // PER_SCENE_SELECT: 逐场景合并
            Map<String, String> mainSections = parseSections(mainLatest.getSectionsJson());
            Map<String, String> branchSections = parseSections(branchLatest.getSectionsJson());
            Map<String, String> merged = new LinkedHashMap<>(mainSections);

            for (Map.Entry<String, String> entry : branchSections.entrySet()) {
                String sceneId = entry.getKey();
                String selection = sceneSelections.getOrDefault(sceneId, "main");
                if ("branch".equals(selection)) {
                    merged.put(sceneId, entry.getValue());
                } else if ("main".equals(selection) && !mainSections.containsKey(sceneId)) {
                    // 分支新增的场景，主线没有，标记为冲突
                    conflicts.add(sceneId);
                }
            }
            mergedSectionsJson = objectMapper.writeValueAsString(merged);
        }

        // 更新稿件内容
        Manuscript manuscript = manuscriptRepository.findById(manuscriptId).orElseThrow();
        manuscript.setSectionsJson(mergedSectionsJson);
        manuscriptRepository.save(manuscript);

        // 创建合并版本
        versionService.createSnapshot(manuscriptId,
            "合并分支: " + branch.getName(), SnapshotType.MERGE, userId);

        // 标记分支为已合并
        branch.setStatus(BranchStatus.MERGED);
        branchRepository.save(branch);

        return new MergeResult(true, conflicts, branch.getName());
    }
}
```

##### AutoSaveService — 自动快照调度

```java
@Service
public class AutoSaveService {

    @Autowired private VersionService versionService;
    @Autowired private AutoSaveConfigRepository configRepository;
    @Autowired private VersionRepository versionRepository;

    // 内存中记录每个稿件的上次自动快照时间，避免频繁查库
    private final ConcurrentHashMap<UUID, Instant> lastAutoSaveTime = new ConcurrentHashMap<>();

    /**
     * 在稿件保存时调用，判断是否需要创建自动快照。
     * 判断逻辑：距离上次自动快照是否超过 auto_save_interval_seconds。
     */
    public void onManuscriptSaved(UUID manuscriptId, UUID userId) {
        AutoSaveConfig config = configRepository.findByUserId(userId)
            .orElse(AutoSaveConfig.defaultConfig(userId));

        Instant lastTime = lastAutoSaveTime.get(manuscriptId);
        Instant now = Instant.now();

        if (lastTime == null || Duration.between(lastTime, now).getSeconds()
                >= config.getAutoSaveIntervalSeconds()) {
            versionService.createSnapshot(manuscriptId, null, SnapshotType.AUTO, userId);
            lastAutoSaveTime.put(manuscriptId, now);
        }
    }

    /**
     * 定时清理任务：每小时执行一次，清理超出上限的自动快照。
     */
    @Scheduled(fixedRate = 3600000)
    public void scheduledCleanup() {
        // 查找所有有自动快照的稿件，逐个检查并清理
        // 保留最新的 max_auto_versions 个自动快照，删除更早的
    }
}
```

#### 3.2.3 流程图

##### 流程 1：自动快照流程

```
前端 ManuscriptWriter                    后端
    │                                      │
    │  scheduleSave() 防抖 1200ms          │
    │──── PUT /api/manuscripts/{id}/       │
    │     sections/{sceneId}               │
    │                                      │
    │                          ManuscriptService.updateSection()
    │                                      │
    │                          AutoSaveService.onManuscriptSaved()
    │                                      │
    │                          ┌─ 距上次快照 < interval? ─── 跳过
    │                          │
    │                          └─ 距上次快照 >= interval?
    │                                      │
    │                          VersionService.createSnapshot(AUTO)
    │                                      │
    │                          ┌─ contentHash == 最新版本? ─── 跳过（内容未变）
    │                          │
    │                          └─ contentHash 不同
    │                                      │
    │                          保存 ManuscriptVersion
    │                                      │
    │                          超出 max_auto_versions? ─── 删除最旧自动快照
    │                                      │
    │  <── 200 OK ────────────────────────│
```

##### 流程 2：手动检查点流程

```
用户点击"创建检查点"
    │
    │  POST /api/v2/manuscripts/{id}/versions
    │  { "label": "第三章定稿" }
    │
    ▼
VersionController.createSnapshot()
    │
    ▼
VersionService.createSnapshot(manuscriptId, "第三章定稿", MANUAL, userId)
    │
    ├─ 读取当前 manuscript.sectionsJson
    ├─ 计算 SHA-256 哈希
    ├─ 查找当前分支最新版本号 → nextVersionNumber
    ├─ 计算 metadata（字数/章节数/场景数）
    ├─ 保存 ManuscriptVersion
    │
    ▼
返回 VersionDto（含 versionNumber, label, createdAt）
```

##### 流程 3：分支创建流程

```
用户在版本时间线上选择某个版本 → 点击"创建分支"
    │
    │  POST /api/v2/manuscripts/{id}/branches
    │  { "fromVersionId": "uuid-v5", "name": "暗线-复仇路线", "description": "..." }
    │
    ▼
BranchService.createBranch()
    │
    ├─ 校验分支名唯一性
    ├─ 创建 ManuscriptBranch 记录
    ├─ 复制源版本 sectionsJson → 新分支初始版本（type=BRANCH_POINT）
    │
    ▼
返回 BranchDto

用户可通过"切换分支"下拉框切换到新分支继续编辑
    │
    │  PUT /api/v2/manuscripts/{id}  { "currentBranchId": "uuid-branch-2" }
    │
    ▼
更新 manuscript.current_branch_id
后续保存操作的自动快照将记录在新分支下
```

##### 流程 4：合并流程（含冲突检测）

```
用户在分支管理器中选择分支 → 点击"合并到主线"
    │
    │  POST /api/v2/manuscripts/{id}/branches/{branchId}/merge
    │  { "strategy": "per_scene_select", "sceneSelections": {...} }
    │
    ▼
BranchService.mergeBranch()
    │
    ├─ 获取主线最新版本 sectionsJson
    ├─ 获取分支最新版本 sectionsJson
    │
    ├─ strategy == REPLACE_ALL?
    │   └─ 直接用分支内容替换主线
    │
    ├─ strategy == PER_SCENE_SELECT?
    │   ├─ 逐场景对比
    │   ├─ 根据 sceneSelections 选择每个场景保留哪个版本
    │   └─ 检测冲突（分支新增但主线也有修改的场景）
    │
    ├─ 更新 manuscript.sectionsJson
    ├─ 创建 merge 类型版本快照
    ├─ 标记分支状态为 merged
    │
    ▼
返回 MergeResult { success, conflicts[], branchName }

若有冲突：
    │
    ▼
前端展示冲突解决 UI
    ├─ 对每个冲突场景展示 side-by-side diff
    ├─ 用户逐个选择保留主线/分支/手动编辑
    └─ 重新提交合并请求（附带解决后的 sceneSelections）
```

##### 流程 5：回滚流程

```
用户在版本时间线上选择某个历史版本 → 点击"回滚到此版本"
    │
    │  POST /api/v2/manuscripts/{id}/versions/{versionId}/rollback
    │
    ▼
VersionService.rollback()
    │
    ├─ 1. 创建当前状态的备份快照（label="回滚前自动备份", type=MANUAL）
    ├─ 2. 读取目标版本的 sectionsJson
    ├─ 3. 覆盖 manuscript.sectionsJson
    ├─ 4. 创建回滚版本记录（label="回滚至 v{N}", type=MANUAL）
    │
    ▼
返回更新后的 ManuscriptDto

注意：回滚是非破坏性的——历史链不会被截断，
      而是在链尾追加新版本，用户随时可以"回滚回滚"。
```

---

### 3.3 API 设计

#### 3.3.1 版本 API

##### GET /api/v2/manuscripts/{manuscriptId}/versions

获取版本列表（分页，支持按分支筛选）。

请求参数：
```
GET /api/v2/manuscripts/550e8400-e29b-41d4-a716-446655440000/versions
    ?branchId=660e8400-e29b-41d4-a716-446655440001
    &page=0
    &size=20
    &sort=createdAt,desc
```

响应：
```json
{
  "content": [
    {
      "id": "770e8400-e29b-41d4-a716-446655440010",
      "manuscriptId": "550e8400-e29b-41d4-a716-446655440000",
      "branchId": "660e8400-e29b-41d4-a716-446655440001",
      "branchName": "main",
      "versionNumber": 42,
      "label": "第三章定稿",
      "snapshotType": "manual",
      "contentHash": "a1b2c3d4e5f6...",
      "metadata": {
        "word_count": 28450,
        "chapter_count": 5,
        "scene_count": 18
      },
      "parentVersionId": "770e8400-e29b-41d4-a716-446655440009",
      "createdBy": "880e8400-e29b-41d4-a716-446655440000",
      "createdAt": "2026-02-17T10:30:00Z"
    }
  ],
  "totalElements": 42,
  "totalPages": 3,
  "number": 0,
  "size": 20
}
```

##### POST /api/v2/manuscripts/{manuscriptId}/versions

创建手动检查点。

请求：
```json
{
  "label": "第三章定稿"
}
```

响应：
```json
{
  "id": "770e8400-e29b-41d4-a716-446655440011",
  "manuscriptId": "550e8400-e29b-41d4-a716-446655440000",
  "branchId": "660e8400-e29b-41d4-a716-446655440001",
  "branchName": "main",
  "versionNumber": 43,
  "label": "第三章定稿",
  "snapshotType": "manual",
  "contentHash": "b2c3d4e5f6a1...",
  "metadata": {
    "word_count": 28500,
    "chapter_count": 5,
    "scene_count": 18
  },
  "parentVersionId": "770e8400-e29b-41d4-a716-446655440010",
  "createdAt": "2026-02-17T11:00:00Z"
}
```

##### GET /api/v2/manuscripts/{manuscriptId}/versions/{versionId}

获取版本详情（含完整 sectionsJson）。

响应：
```json
{
  "id": "770e8400-e29b-41d4-a716-446655440010",
  "manuscriptId": "550e8400-e29b-41d4-a716-446655440000",
  "versionNumber": 42,
  "label": "第三章定稿",
  "snapshotType": "manual",
  "sectionsJson": {
    "scene-uuid-001": "<p>林逸站在青云山巅，俯瞰云海翻涌...</p>",
    "scene-uuid-002": "<p>剑光如虹，划破长空...</p>"
  },
  "metadata": {
    "word_count": 28450,
    "chapter_count": 5,
    "scene_count": 18
  },
  "createdAt": "2026-02-17T10:30:00Z"
}
```

##### POST /api/v2/manuscripts/{manuscriptId}/versions/{versionId}/rollback

回滚到指定版本。

响应：
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "title": "正文稿",
  "sectionsJson": { "...": "..." },
  "rollbackFromVersion": 42,
  "newVersionNumber": 45,
  "message": "已回滚至 v42，当前状态已备份为 v44"
}
```

##### GET /api/v2/manuscripts/{manuscriptId}/versions/diff

计算两个版本之间的差异。

请求参数：
```
GET /api/v2/manuscripts/{manuscriptId}/versions/diff
    ?from=770e8400-e29b-41d4-a716-446655440005
    &to=770e8400-e29b-41d4-a716-446655440010
```

响应：
```json
{
  "fromVersionId": "770e8400-e29b-41d4-a716-446655440005",
  "toVersionId": "770e8400-e29b-41d4-a716-446655440010",
  "fromVersionNumber": 37,
  "toVersionNumber": 42,
  "totalScenesChanged": 3,
  "totalLinesAdded": 45,
  "totalLinesRemoved": 12,
  "sceneDiffs": [
    {
      "sceneId": "scene-uuid-001",
      "changeType": "modified",
      "addedLines": 20,
      "removedLines": 5,
      "deltas": [
        {
          "type": "CHANGE",
          "sourcePosition": 3,
          "sourceLines": ["林逸站在山脚，仰望青云山。"],
          "targetPosition": 3,
          "targetLines": ["林逸站在青云山巅，俯瞰云海翻涌。"]
        },
        {
          "type": "INSERT",
          "sourcePosition": 10,
          "sourceLines": [],
          "targetPosition": 10,
          "targetLines": [
            "一道剑光从云层中射出，直奔林逸而来。",
            "他侧身闪避，剑气擦肩而过，削断了身后的一棵古松。"
          ]
        }
      ]
    },
    {
      "sceneId": "scene-uuid-003",
      "changeType": "added",
      "addedLines": 25,
      "removedLines": 0,
      "deltas": [
        {
          "type": "INSERT",
          "sourcePosition": 0,
          "sourceLines": [],
          "targetPosition": 0,
          "targetLines": ["（新增场景全部内容...）"]
        }
      ]
    }
  ]
}
```

#### 3.3.2 分支 API

##### GET /api/v2/manuscripts/{manuscriptId}/branches

获取分支列表。

响应：
```json
[
  {
    "id": "660e8400-e29b-41d4-a716-446655440001",
    "manuscriptId": "550e8400-e29b-41d4-a716-446655440000",
    "name": "main",
    "description": "主线",
    "sourceVersionId": null,
    "status": "active",
    "isMain": true,
    "latestVersionNumber": 42,
    "versionCount": 42,
    "createdAt": "2026-01-15T08:00:00Z",
    "updatedAt": "2026-02-17T10:30:00Z"
  },
  {
    "id": "660e8400-e29b-41d4-a716-446655440002",
    "manuscriptId": "550e8400-e29b-41d4-a716-446655440000",
    "name": "暗线-复仇路线",
    "description": "探索主角选择复仇而非宽恕的情节走向",
    "sourceVersionId": "770e8400-e29b-41d4-a716-446655440005",
    "status": "active",
    "isMain": false,
    "latestVersionNumber": 8,
    "versionCount": 8,
    "createdAt": "2026-02-10T14:00:00Z",
    "updatedAt": "2026-02-17T09:00:00Z"
  }
]
```

##### POST /api/v2/manuscripts/{manuscriptId}/branches

创建新分支。

请求：
```json
{
  "fromVersionId": "770e8400-e29b-41d4-a716-446655440005",
  "name": "暗线-复仇路线",
  "description": "探索主角选择复仇而非宽恕的情节走向"
}
```

响应：
```json
{
  "id": "660e8400-e29b-41d4-a716-446655440002",
  "manuscriptId": "550e8400-e29b-41d4-a716-446655440000",
  "name": "暗线-复仇路线",
  "description": "探索主角选择复仇而非宽恕的情节走向",
  "sourceVersionId": "770e8400-e29b-41d4-a716-446655440005",
  "status": "active",
  "isMain": false,
  "createdAt": "2026-02-17T14:00:00Z"
}
```

##### PUT /api/v2/manuscripts/{manuscriptId}/branches/{branchId}

更新分支信息（名称、描述）。

请求：
```json
{
  "name": "暗线-复仇路线（已调整）",
  "description": "更新后的描述"
}
```

##### POST /api/v2/manuscripts/{manuscriptId}/branches/{branchId}/merge

合并分支到主线。

请求：
```json
{
  "strategy": "per_scene_select",
  "sceneSelections": {
    "scene-uuid-001": "branch",
    "scene-uuid-002": "main",
    "scene-uuid-003": "branch"
  }
}
```

响应：
```json
{
  "success": true,
  "conflicts": [],
  "branchName": "暗线-复仇路线",
  "mergeVersionNumber": 43,
  "message": "分支 '暗线-复仇路线' 已成功合并到主线"
}
```

冲突响应示例：
```json
{
  "success": false,
  "conflicts": [
    {
      "sceneId": "scene-uuid-004",
      "reason": "主线和分支均修改了此场景",
      "mainContent": "主线版本内容...",
      "branchContent": "分支版本内容..."
    }
  ],
  "branchName": "暗线-复仇路线",
  "message": "存在 1 个冲突场景，请解决后重新提交"
}
```

##### DELETE /api/v2/manuscripts/{manuscriptId}/branches/{branchId}

废弃分支（软删除，标记为 abandoned）。

响应：
```json
{
  "id": "660e8400-e29b-41d4-a716-446655440002",
  "status": "abandoned",
  "message": "分支 '暗线-复仇路线' 已废弃"
}
```

#### 3.3.3 自动保存配置 API

##### GET /api/v2/users/me/auto-save-config

获取当前用户的自动保存配置。

响应：
```json
{
  "id": "990e8400-e29b-41d4-a716-446655440001",
  "userId": "880e8400-e29b-41d4-a716-446655440000",
  "autoSaveIntervalSeconds": 300,
  "maxAutoVersions": 100,
  "createdAt": "2026-01-15T08:00:00Z",
  "updatedAt": "2026-02-17T10:00:00Z"
}
```

##### PUT /api/v2/users/me/auto-save-config

更新自动保存配置。

请求：
```json
{
  "autoSaveIntervalSeconds": 600,
  "maxAutoVersions": 50
}
```

响应：同 GET 格式。

---

### 3.4 前端设计

#### 3.4.1 组件结构

```
frontend/src/components/version/
├── VersionHistoryPanel.tsx          // 版本历史主面板（时间线视图）
│   ├── VersionTimelineItem.tsx      // 时间线上的单个版本节点
│   └── BranchIndicator.tsx          // 分支/合并的可视化指示器
├── DiffViewer.tsx                   // 差异对比主组件
│   ├── SideBySideDiff.tsx           // 并排对比视图
│   ├── UnifiedDiff.tsx              // 统一对比视图
│   └── SceneDiffSelector.tsx        // 场景选择器（选择对比哪个场景）
├── BranchManager.tsx                // 分支管理主组件
│   ├── BranchList.tsx               // 分支列表
│   ├── CreateBranchDialog.tsx       // 创建分支对话框
│   └── MergeBranchDialog.tsx        // 合并分支对话框（含冲突解决 UI）
├── RollbackConfirmDialog.tsx        // 回滚确认对话框
├── AutoSaveSettings.tsx             // 自动保存设置面板
└── hooks/
    ├── useVersionHistory.ts         // 版本历史数据 hook
    ├── useBranches.ts               // 分支数据 hook
    └── useDiff.ts                   // 差异计算 hook
```

#### 3.4.2 VersionHistoryPanel — 版本历史面板

作为 `ManuscriptWriter.tsx` 的右侧面板（替换或并列于 CopilotSidebar），以垂直时间线形式展示版本历史。

```tsx
interface VersionHistoryPanelProps {
  manuscriptId: string;
  currentBranchId: string;
  onRollback: (versionId: string) => void;
  onCompare: (fromId: string, toId: string) => void;
  onCreateCheckpoint: (label: string) => void;
}

const VersionHistoryPanel: React.FC<VersionHistoryPanelProps> = ({
  manuscriptId, currentBranchId, onRollback, onCompare, onCreateCheckpoint
}) => {
  const { versions, isLoading, hasMore, loadMore } = useVersionHistory(
    manuscriptId, currentBranchId
  );
  const [selectedVersions, setSelectedVersions] = useState<string[]>([]);

  return (
    <div className="flex flex-col h-full">
      {/* 顶部操作栏 */}
      <div className="flex items-center justify-between p-3 border-b">
        <h3 className="text-sm font-semibold">版本历史</h3>
        <div className="flex gap-1">
          <CreateCheckpointButton onSubmit={onCreateCheckpoint} />
          <BranchSwitcher manuscriptId={manuscriptId} />
        </div>
      </div>

      {/* 对比操作栏（选中两个版本时显示） */}
      {selectedVersions.length === 2 && (
        <div className="p-2 bg-muted border-b">
          <Button size="sm" onClick={() => onCompare(selectedVersions[0], selectedVersions[1])}>
            对比选中的两个版本
          </Button>
        </div>
      )}

      {/* 时间线 */}
      <ScrollArea className="flex-1">
        <div className="relative pl-6 pr-3 py-3">
          {/* 时间线竖线 */}
          <div className="absolute left-[18px] top-0 bottom-0 w-px bg-border" />

          {versions.map((version) => (
            <VersionTimelineItem
              key={version.id}
              version={version}
              isSelected={selectedVersions.includes(version.id)}
              onSelect={() => toggleSelection(version.id)}
              onRollback={() => onRollback(version.id)}
            />
          ))}

          {hasMore && (
            <Button variant="ghost" size="sm" onClick={loadMore}>
              加载更多
            </Button>
          )}
        </div>
      </ScrollArea>
    </div>
  );
};
```

#### 3.4.3 VersionTimelineItem — 时间线节点

```tsx
interface VersionTimelineItemProps {
  version: VersionDto;
  isSelected: boolean;
  onSelect: () => void;
  onRollback: () => void;
}

const VersionTimelineItem: React.FC<VersionTimelineItemProps> = ({
  version, isSelected, onSelect, onRollback
}) => {
  const typeIcon = {
    auto: <Clock className="h-3 w-3" />,
    manual: <Flag className="h-3 w-3" />,
    branch_point: <GitBranch className="h-3 w-3" />,
    merge: <GitMerge className="h-3 w-3" />,
  };

  const typeColor = {
    auto: "bg-muted-foreground",
    manual: "bg-primary",
    branch_point: "bg-orange-500",
    merge: "bg-green-500",
  };

  return (
    <div
      className={cn(
        "relative flex items-start gap-3 py-2 px-2 rounded-md cursor-pointer",
        "hover:bg-accent transition-colors",
        isSelected && "bg-accent ring-1 ring-primary"
      )}
      onClick={onSelect}
    >
      {/* 时间线圆点 */}
      <div className={cn(
        "absolute -left-[21px] mt-1.5 h-3 w-3 rounded-full border-2 border-background",
        typeColor[version.snapshotType]
      )} />

      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2">
          {typeIcon[version.snapshotType]}
          <span className="text-xs font-medium">v{version.versionNumber}</span>
          {version.label && (
            <Badge variant="outline" className="text-xs">{version.label}</Badge>
          )}
        </div>
        <div className="text-xs text-muted-foreground mt-0.5">
          {formatRelativeTime(version.createdAt)}
          {version.metadata && ` · ${version.metadata.word_count.toLocaleString()} 字`}
        </div>
      </div>

      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" size="icon" className="h-6 w-6">
            <MoreHorizontal className="h-3 w-3" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          <DropdownMenuItem onClick={onRollback}>
            <RotateCcw className="mr-2 h-3 w-3" /> 回滚到此版本
          </DropdownMenuItem>
          <DropdownMenuItem>
            <GitBranch className="mr-2 h-3 w-3" /> 从此版本创建分支
          </DropdownMenuItem>
          <DropdownMenuItem>
            <Eye className="mr-2 h-3 w-3" /> 预览此版本
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
};
```

#### 3.4.4 DiffViewer — 差异对比组件

基于 `react-diff-viewer-continued` 封装，支持并排和统一两种视图模式。

```tsx
interface DiffViewerProps {
  manuscriptId: string;
  fromVersionId: string;
  toVersionId: string;
}

const DiffViewer: React.FC<DiffViewerProps> = ({
  manuscriptId, fromVersionId, toVersionId
}) => {
  const { diffResult, isLoading } = useDiff(manuscriptId, fromVersionId, toVersionId);
  const [selectedSceneId, setSelectedSceneId] = useState<string | null>(null);
  const [viewMode, setViewMode] = useState<"split" | "unified">("split");

  if (isLoading) return <Skeleton className="h-full" />;
  if (!diffResult) return <div className="p-4 text-muted-foreground">无差异数据</div>;

  const currentSceneDiff = selectedSceneId
    ? diffResult.sceneDiffs.find(d => d.sceneId === selectedSceneId)
    : diffResult.sceneDiffs[0];

  return (
    <div className="flex flex-col h-full">
      {/* 顶部统计栏 */}
      <div className="flex items-center justify-between p-3 border-b">
        <div className="text-sm">
          <span className="text-green-600">+{diffResult.totalLinesAdded}</span>
          {" / "}
          <span className="text-red-600">-{diffResult.totalLinesRemoved}</span>
          {" · "}
          {diffResult.totalScenesChanged} 个场景有变化
        </div>
        <div className="flex gap-2">
          <SceneDiffSelector
            sceneDiffs={diffResult.sceneDiffs}
            selectedSceneId={selectedSceneId}
            onSelect={setSelectedSceneId}
          />
          <ToggleGroup type="single" value={viewMode} onValueChange={setViewMode}>
            <ToggleGroupItem value="split">并排</ToggleGroupItem>
            <ToggleGroupItem value="unified">统一</ToggleGroupItem>
          </ToggleGroup>
        </div>
      </div>

      {/* 差异内容 */}
      <ScrollArea className="flex-1">
        {currentSceneDiff && (
          viewMode === "split"
            ? <SideBySideDiff sceneDiff={currentSceneDiff} />
            : <UnifiedDiff sceneDiff={currentSceneDiff} />
        )}
      </ScrollArea>
    </div>
  );
};
```

#### 3.4.5 MergeBranchDialog — 合并分支对话框

```tsx
interface MergeBranchDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  manuscriptId: string;
  branch: BranchDto;
}

const MergeBranchDialog: React.FC<MergeBranchDialogProps> = ({
  open, onOpenChange, manuscriptId, branch
}) => {
  const [strategy, setStrategy] = useState<"replace_all" | "per_scene_select">("replace_all");
  const [sceneSelections, setSceneSelections] = useState<Record<string, string>>({});
  const [conflicts, setConflicts] = useState<ConflictInfo[]>([]);
  const [step, setStep] = useState<"strategy" | "resolve" | "confirm">("strategy");

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl max-h-[80vh]">
        <DialogHeader>
          <DialogTitle>合并分支: {branch.name}</DialogTitle>
          <DialogDescription>
            将分支 "{branch.name}" 的内容合并到主线
          </DialogDescription>
        </DialogHeader>

        {step === "strategy" && (
          <div className="space-y-4">
            <RadioGroup value={strategy} onValueChange={setStrategy}>
              <div className="flex items-start gap-3 p-3 border rounded-lg">
                <RadioGroupItem value="replace_all" />
                <div>
                  <Label className="font-medium">整体替换</Label>
                  <p className="text-sm text-muted-foreground">
                    用分支的最新内容完全替换主线内容
                  </p>
                </div>
              </div>
              <div className="flex items-start gap-3 p-3 border rounded-lg">
                <RadioGroupItem value="per_scene_select" />
                <div>
                  <Label className="font-medium">逐场景选择</Label>
                  <p className="text-sm text-muted-foreground">
                    对每个有差异的场景，分别选择保留主线或分支版本
                  </p>
                </div>
              </div>
            </RadioGroup>
          </div>
        )}

        {step === "resolve" && conflicts.length > 0 && (
          <ScrollArea className="max-h-[50vh]">
            {conflicts.map((conflict) => (
              <div key={conflict.sceneId} className="border rounded-lg p-3 mb-3">
                <div className="font-medium mb-2">场景: {conflict.sceneId}</div>
                <ReactDiffViewer
                  oldValue={conflict.mainContent}
                  newValue={conflict.branchContent}
                  splitView={true}
                  leftTitle="主线"
                  rightTitle={branch.name}
                />
                <RadioGroup
                  value={sceneSelections[conflict.sceneId] || "main"}
                  onValueChange={(v) => setSceneSelections(prev => ({
                    ...prev, [conflict.sceneId]: v
                  }))}
                  className="flex gap-4 mt-2"
                >
                  <div className="flex items-center gap-2">
                    <RadioGroupItem value="main" />
                    <Label>保留主线</Label>
                  </div>
                  <div className="flex items-center gap-2">
                    <RadioGroupItem value="branch" />
                    <Label>使用分支</Label>
                  </div>
                </RadioGroup>
              </div>
            ))}
          </ScrollArea>
        )}

        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>取消</Button>
          <Button onClick={handleMerge}>确认合并</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};
```

#### 3.4.6 RollbackConfirmDialog — 回滚确认对话框

```tsx
const RollbackConfirmDialog: React.FC<{
  open: boolean;
  onOpenChange: (open: boolean) => void;
  version: VersionDto;
  onConfirm: () => void;
}> = ({ open, onOpenChange, version, onConfirm }) => (
  <AlertDialog open={open} onOpenChange={onOpenChange}>
    <AlertDialogContent>
      <AlertDialogHeader>
        <AlertDialogTitle>确认回滚</AlertDialogTitle>
        <AlertDialogDescription>
          将稿件内容回滚到 v{version.versionNumber}
          {version.label && ` (${version.label})`}，
          创建于 {formatDateTime(version.createdAt)}。
          <br /><br />
          当前内容将自动备份为新版本，不会丢失。
        </AlertDialogDescription>
      </AlertDialogHeader>
      <AlertDialogFooter>
        <AlertDialogCancel>取消</AlertDialogCancel>
        <AlertDialogAction onClick={onConfirm}>确认回滚</AlertDialogAction>
      </AlertDialogFooter>
    </AlertDialogContent>
  </AlertDialog>
);
```

#### 3.4.7 AutoSaveSettings — 自动保存设置

```tsx
const AutoSaveSettings: React.FC = () => {
  const { config, updateConfig, isLoading } = useAutoSaveConfig();

  return (
    <div className="space-y-4 p-4">
      <div>
        <Label>自动快照间隔</Label>
        <Select
          value={String(config.autoSaveIntervalSeconds)}
          onValueChange={(v) => updateConfig({ autoSaveIntervalSeconds: Number(v) })}
        >
          <SelectTrigger><SelectValue /></SelectTrigger>
          <SelectContent>
            <SelectItem value="60">1 分钟</SelectItem>
            <SelectItem value="300">5 分钟（默认）</SelectItem>
            <SelectItem value="600">10 分钟</SelectItem>
            <SelectItem value="1800">30 分钟</SelectItem>
            <SelectItem value="0">关闭自动快照</SelectItem>
          </SelectContent>
        </Select>
        <p className="text-xs text-muted-foreground mt-1">
          在此间隔内的多次保存只会生成一个自动快照
        </p>
      </div>

      <div>
        <Label>每个分支最大自动快照数</Label>
        <Input
          type="number"
          min={10}
          max={500}
          value={config.maxAutoVersions}
          onChange={(e) => updateConfig({ maxAutoVersions: Number(e.target.value) })}
        />
        <p className="text-xs text-muted-foreground mt-1">
          超出上限后自动清理最旧的自动快照（手动检查点不受影响）
        </p>
      </div>
    </div>
  );
};
```

#### 3.4.8 ManuscriptWriter 集成

在现有 `ManuscriptWriter.tsx` 中集成版本控制功能：

```tsx
// ManuscriptWriter.tsx 中的变更要点：

// 1. 新增状态
const [showVersionHistory, setShowVersionHistory] = useState(false);
const [showDiffViewer, setShowDiffViewer] = useState(false);
const [diffVersions, setDiffVersions] = useState<{ from: string; to: string } | null>(null);
const [currentBranchId, setCurrentBranchId] = useState<string>("");

// 2. "历史版本"按钮绑定事件（替换当前空操作）
<Button
  variant="outline"
  size="sm"
  onClick={() => setShowVersionHistory(!showVersionHistory)}
>
  <History className="mr-2 h-4 w-4" /> 历史版本
</Button>

// 3. 保存时触发自动快照
const scheduleSave = (html: string) => {
  // ... 现有防抖逻辑 ...
  // 保存成功后，后端 ManuscriptService 会自动调用 AutoSaveService
};

// 4. 手动检查点按钮
<Button variant="outline" size="sm" onClick={() => setShowCheckpointDialog(true)}>
  <Flag className="mr-2 h-4 w-4" /> 创建检查点
</Button>

// 5. 分支切换下拉框
<BranchSwitcher
  manuscriptId={selectedManuscriptId}
  currentBranchId={currentBranchId}
  onSwitch={setCurrentBranchId}
/>

// 6. 版本历史面板（条件渲染）
{showVersionHistory && (
  <div className="w-80 border-l">
    <VersionHistoryPanel
      manuscriptId={selectedManuscriptId}
      currentBranchId={currentBranchId}
      onRollback={handleRollback}
      onCompare={(from, to) => {
        setDiffVersions({ from, to });
        setShowDiffViewer(true);
      }}
      onCreateCheckpoint={handleCreateCheckpoint}
    />
  </div>
)}
```

---

### 3.5 Prompt 工程

版本控制模块主要是数据/UI 功能，AI 介入点较少。唯一的 AI 辅助功能是"版本变更摘要"——当用户查看两个版本的差异时，可选择让 AI 生成一段自然语言描述来概括变更内容。

#### 版本变更摘要 Prompt

```
你是一位专业的小说编辑助手。请根据以下两个版本之间的差异，用简洁的中文概括本次修改的要点。

## 差异统计
- 变更场景数: {totalScenesChanged}
- 新增行数: {totalLinesAdded}
- 删除行数: {totalLinesRemoved}

## 各场景变更详情
{sceneDiffs.map(diff => `
### 场景: {diff.sceneId}
变更类型: {diff.changeType}
删除内容:
{diff.removedContent}

新增内容:
{diff.addedContent}
`)}

## 要求
1. 用 2-3 句话概括主要修改内容
2. 重点说明情节、角色、场景描写方面的变化
3. 如果有新增或删除的场景，特别指出
4. 语言简洁，避免重复差异细节
```

调用时机：用户在 DiffViewer 中点击"AI 总结变更"按钮时触发，结果展示在 diff 视图顶部。

---

## 4. 与现有代码的集成点

### 4.1 后端集成

| 文件 | 变更内容 |
|------|----------|
| `backend/src/main/java/com/ainovel/app/manuscript/model/Manuscript.java` | 新增 `currentBranchId` 字段（CHAR(36)，FK -> manuscript_branches.id） |
| `backend/src/main/java/com/ainovel/app/manuscript/ManuscriptService.java` | 在 `updateSection()` 方法末尾调用 `autoSaveService.onManuscriptSaved(manuscriptId, userId)` 触发自动快照判断 |
| `backend/src/main/java/com/ainovel/app/manuscript/ManuscriptService.java` | 在 `create()` 方法中调用 `branchService.initMainBranch(manuscript.getId())` 初始化主分支 |
| `backend/src/main/java/com/ainovel/app/manuscript/ManuscriptController.java` | 新增版本控制相关端点的路由委托（或直接在 VersionController 中独立处理） |
| `backend/pom.xml` | 确认 `java-diff-utils` 依赖已存在（v2 总体规划中已列出） |

### 4.2 前端集成

| 文件 | 变更内容 |
|------|----------|
| `frontend/src/pages/Workbench/tabs/ManuscriptWriter.tsx` | 集成版本历史面板、分支切换器、检查点按钮（详见 3.4.8） |
| `frontend/src/pages/Workbench/tabs/ManuscriptWriter.tsx` | "历史版本"按钮（第208行）绑定 `setShowVersionHistory` 事件 |
| `frontend/src/lib/mock-api.ts` 或 `frontend/src/lib/api.ts` | 新增版本控制相关 API 调用方法 |
| `frontend/src/types/index.ts` | 新增 `VersionDto`、`BranchDto`、`DiffResult` 等类型定义 |
| `frontend/package.json` | 确认 `react-diff-viewer-continued` 依赖已存在 |

### 4.3 数据库迁移

需要创建 Flyway/Liquibase 迁移脚本（或 JPA auto-ddl），按以下顺序执行：

1. 创建 `manuscript_branches` 表
2. 创建 `manuscript_versions` 表（依赖 `manuscript_branches`）
3. 创建 `version_diffs` 表（依赖 `manuscript_versions`）
4. 创建 `auto_save_config` 表
5. 为 `manuscripts` 表添加 `current_branch_id` 列
6. 数据迁移：为所有现有稿件创建默认 `main` 分支，并创建初始版本快照

---

## 5. 实施注意事项

### 5.1 存储增长管理

`manuscript_versions.sections_json` 存储完整快照，对于长篇小说（10万字+）每个快照可能占用 200KB-1MB。按每天 20 个自动快照计算，单个稿件每月可能产生 600 个快照，约 120MB-600MB。

应对策略：
- 自动快照数量上限（默认 100/分支），FIFO 清理
- `content_hash` 去重：内容未变时不创建新快照
- 未来可考虑增量存储（只存 diff 而非全量），但 v2 阶段优先保证实现简单性
- 定期归档：超过 90 天的自动快照可压缩存储或迁移到冷存储

### 5.2 Diff 性能优化

对于大型稿件（50+ 场景），逐场景计算 diff 可能耗时较长。

应对策略：
- `version_diffs` 缓存表避免重复计算
- 先比较 `content_hash`，哈希相同则跳过 diff 计算
- 逐场景并行计算 diff（使用 `CompletableFuture`）
- 前端按需加载：先展示变更场景列表，用户点击某个场景时再加载该场景的详细 diff

### 5.3 冲突解决策略

分支合并的冲突检测采用简化策略（非 Git 级别的三路合并）：
- 以场景（scene）为最小冲突单元，不做行级合并
- 如果主线和分支都修改了同一个场景，标记为冲突，由用户选择保留哪个版本
- 未来可考虑引入三路合并（基于分支点版本作为 base），但 v2 阶段不实现

### 5.4 现有稿件数据迁移

系统升级时需要为所有现有稿件执行一次性迁移：

```sql
-- 迁移脚本伪代码
-- 1. 为每个现有稿件创建 main 分支
INSERT INTO manuscript_branches (id, manuscript_id, name, status, is_main, created_at, updated_at)
SELECT UUID(), id, 'main', 'active', 1, NOW(), NOW()
FROM manuscripts;

-- 2. 为每个现有稿件创建初始版本快照
INSERT INTO manuscript_versions (id, manuscript_id, branch_id, version_number, snapshot_type,
                                  content_hash, sections_json, created_by, created_at)
SELECT UUID(), m.id, b.id, 1, 'manual',
       SHA2(m.sections_json, 256), m.sections_json,
       (SELECT id FROM users LIMIT 1), -- 系统用户
       NOW()
FROM manuscripts m
JOIN manuscript_branches b ON b.manuscript_id = m.id AND b.is_main = 1;

-- 3. 更新 manuscripts.current_branch_id
UPDATE manuscripts m
SET current_branch_id = (
    SELECT id FROM manuscript_branches b
    WHERE b.manuscript_id = m.id AND b.is_main = 1
);
```

### 5.5 并发安全

- 版本号递增使用数据库级别的 `SELECT ... FOR UPDATE` 或乐观锁（`@Version`）防止并发冲突
- 自动快照的时间间隔判断使用 `ConcurrentHashMap` 保证线程安全
- 回滚操作使用 `@Transactional` 保证原子性（备份 + 恢复 + 新版本三步不可分割）

---

## 6. 验收标准

### 6.1 功能验收

| 编号 | 验收项 | 验收条件 | 优先级 |
|------|--------|----------|--------|
| AC-01 | 自动快照 | 编辑稿件并保存后，在配置的间隔时间后自动创建版本快照，版本列表中可见 `auto` 类型记录 | P0 |
| AC-02 | 内容去重 | 连续保存相同内容不会创建重复快照（通过 content_hash 验证） | P0 |
| AC-03 | 手动检查点 | 点击"创建检查点"按钮，输入标签后成功创建 `manual` 类型版本，标签正确显示 | P0 |
| AC-04 | 版本列表 | 版本历史面板以时间线形式展示所有版本，支持分页加载，显示版本号、类型图标、标签、时间、字数 | P0 |
| AC-05 | 版本对比 | 选中两个版本后点击"对比"，正确展示逐场景的行级差异，支持并排和统一两种视图 | P0 |
| AC-06 | 版本回滚 | 点击"回滚到此版本"后，稿件内容恢复到目标版本，当前内容自动备份，历史链不断裂 | P0 |
| AC-07 | 创建分支 | 从任意版本创建分支，分支名唯一，分支初始内容与源版本一致 | P1 |
| AC-08 | 切换分支 | 切换分支后，编辑器加载该分支最新版本的内容，后续保存记录在该分支下 | P1 |
| AC-09 | 合并分支（整体替换） | 选择"整体替换"策略合并分支，主线内容被分支内容完全替换，分支标记为 merged | P1 |
| AC-10 | 合并分支（逐场景选择） | 选择"逐场景选择"策略，对有差异的场景逐个选择保留主线或分支版本 | P1 |
| AC-11 | 冲突检测 | 主线和分支都修改了同一场景时，正确标记为冲突并展示冲突解决 UI | P1 |
| AC-12 | 自动清理 | 自动快照数量超过 max_auto_versions 后，最旧的自动快照被自动删除，手动检查点不受影响 | P1 |
| AC-13 | 配置管理 | 用户可修改自动快照间隔和最大数量，修改后立即生效 | P2 |
| AC-14 | AI 变更摘要 | 在 diff 视图中点击"AI 总结变更"，生成准确的自然语言变更描述 | P2 |
| AC-15 | 数据迁移 | 升级后所有现有稿件自动拥有 main 分支和初始版本快照，功能正常可用 | P0 |

### 6.2 性能验收

| 编号 | 验收项 | 验收条件 |
|------|--------|----------|
| PERF-01 | 快照创建 | 10万字稿件的快照创建耗时 < 500ms |
| PERF-02 | 版本列表 | 100 个版本的列表查询耗时 < 200ms |
| PERF-03 | Diff 计算 | 两个 10万字版本的全量 diff 计算耗时 < 3s |
| PERF-04 | 单场景 Diff | 单个场景（5000字）的 diff 计算耗时 < 200ms |
| PERF-05 | 回滚操作 | 回滚操作（含备份）耗时 < 1s |
