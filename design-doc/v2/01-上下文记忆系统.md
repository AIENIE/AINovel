# 上下文记忆系统

## 文档信息

| 字段 | 值 |
|------|-----|
| 版本 | v2.0 |
| 日期 | 2026-02-17 |
| 优先级 | P0 |
| 关联模块 | 02-风格画像, 03-Beta-Reader, 06-多模型协作 |

---

## 1. 背景与动机

### 1.1 问题陈述

当前 v1 版本的 AINovel 系统存在以下核心缺陷：

1. **无持久化上下文记忆**：每次 AI 调用（通过 `AiService.chat()` -> `AiGatewayGrpcClient.chatCompletions()`）都是无状态的。系统仅将当前场景文本和简单的 `contextData`（故事标题、大纲标题、章节标题、场景摘要）传递给 AI，没有任何跨场景、跨章节的记忆机制。

2. **世界观设定丢失**：`World` 实体虽然存储了 `modulesJson`（世界模块）和 `moduleProgressJson`，但这些数据从未被注入到 AI 写作提示词中。作者在 WorldBuilder 中精心构建的地理、政治、魔法体系等设定，在实际创作时被完全忽略。

3. **角色一致性断裂**：`CharacterCard` 存储了 `name`、`synopsis`、`details`、`relationships`，但在长篇小说创作中（10万字以上），AI 无法记住角色在第3章的性格转变、在第7章获得的新能力、或在第12章建立的新关系。角色行为前后矛盾。

4. **实体关系不可追踪**：小说中的人物关系网、地点关联、事件因果链等复杂关系，目前只能靠作者人工维护。没有自动化的实体提取和关系图谱。

5. **Token 浪费**：由于缺乏智能上下文筛选，要么注入过少信息导致 AI "失忆"，要么注入过多无关信息浪费 Token 预算。

### 1.2 业界参考

| 产品/论文 | 核心机制 | 借鉴点 |
|-----------|----------|--------|
| **NovelAI Lorebook** | 关键词触发式条目注入，支持优先级和 Token 预算控制 | 条目结构设计、关键词匹配策略、插入位置控制 |
| **Sudowrite Story Bible** | 自动从已写文本中提取角色/地点/物品信息，构建故事圣经 | 自动实体提取流程、增量更新机制 |
| **Character.AI 持久记忆** | 对话级别的长期记忆存储与检索，基于语义相似度召回 | 语义检索策略、记忆衰减机制 |
| **KAG (Knowledge Augmented Generation)** | 将知识图谱与 LLM 结合，通过结构化知识增强生成质量，减少幻觉 | 图谱构建策略、子图检索算法、Prompt 注入模板 |
| **GraphRAG (Microsoft Research)** | 基于社区检测的图谱摘要，支持全局性问题的回答 | 多层级摘要策略、社区聚类方法 |
| **Dramatron (DeepMind)** | 层次化故事生成，维护角色档案和场景上下文 | 层次化上下文组织、角色档案动态更新 |

---

## 2. 设计目标

1. **持久化世界与角色上下文**：将 World 模块数据、CharacterCard 信息、以及用户自定义的 Lorebook 条目持久化存储，确保 AI 在任意章节/场景的调用中都能访问完整的世界观设定。

2. **自动实体提取**：当作者保存稿件或 AI 生成文本后，系统自动调用 AI 从文本中提取命名实体（角色、地点、物品、事件、概念），并以结构化形式存储，支持人工审核确认。

3. **知识图谱关系追踪**：使用 Neo4j 构建故事知识图谱，自动维护角色关系网、事件因果链、角色-地点关联等结构化关系，支持多跳查询和子图检索。

4. **语义检索上下文注入**：在 AI 调用前，基于当前写作文本的关键词匹配和语义相似度，智能检索最相关的 Lorebook 条目、图谱子图和历史场景摘要，在 Token 预算内组装最优上下文。

5. **用户可编辑 Lorebook**：提供完整的 Lorebook CRUD 界面，支持手动创建/编辑/删除条目，支持批量导入，支持按类别筛选和关键词搜索。

6. **可视化知识图谱**：提供交互式图谱可视化界面，支持节点过滤、关系浏览、子图查询，帮助作者直观理解故事中的实体关系网络。

7. **场景上下文快照**：在每个场景写作完成后自动生成上下文快照（活跃角色、当前地点、时间线位置、场景摘要），为后续场景提供连贯的前情提要。

8. **Token 预算管理**：每个 Lorebook 条目和上下文组件都有独立的 Token 预算，系统根据优先级和相关性在总预算内进行最优分配。

---

## 3. 详细设计

### 3.1 数据模型

#### 3.1.1 MySQL 新增表

##### 表 1：`lorebook_entries` — Lorebook 条目表

存储用户自定义的世界观条目，支持关键词触发注入。

```sql
CREATE TABLE lorebook_entries (
    id              CHAR(36)        NOT NULL    COMMENT '主键 UUID',
    story_id        CHAR(36)        NOT NULL    COMMENT '所属故事 FK -> stories.id',
    user_id         CHAR(36)        NOT NULL    COMMENT '创建用户 FK -> users.id',
    entry_key       VARCHAR(200)    NOT NULL    COMMENT '条目标识键（主触发词）',
    display_name    VARCHAR(200)    NOT NULL    COMMENT '显示名称',
    category        ENUM('character','location','item','event','concept','custom')
                                    NOT NULL DEFAULT 'custom'
                                                COMMENT '条目类别',
    content         TEXT            NOT NULL    COMMENT '条目正文内容（注入到 Prompt 的文本）',
    keywords_json   TEXT            NULL        COMMENT '触发关键词 JSON 数组，如 ["林逸","小逸","逸哥"]',
    priority        INT             NOT NULL DEFAULT 0
                                                COMMENT '注入优先级，数值越大越优先',
    enabled         TINYINT(1)      NOT NULL DEFAULT 1
                                                COMMENT '是否启用',
    insertion_position ENUM('before_scene','after_scene','system_prompt')
                                    NOT NULL DEFAULT 'before_scene'
                                                COMMENT '注入位置',
    token_budget    INT             NOT NULL DEFAULT 500
                                                COMMENT '该条目最大 Token 数',
    created_at      TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    PRIMARY KEY (id),
    INDEX idx_lorebook_story (story_id),
    INDEX idx_lorebook_user (user_id),
    INDEX idx_lorebook_category (story_id, category),
    INDEX idx_lorebook_enabled (story_id, enabled),
    CONSTRAINT fk_lorebook_story FOREIGN KEY (story_id) REFERENCES stories(id) ON DELETE CASCADE,
    CONSTRAINT fk_lorebook_user  FOREIGN KEY (user_id)  REFERENCES users(id)   ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  COMMENT='Lorebook 世界观条目表';
```

##### 表 2：`context_snapshots` — 场景上下文快照表

存储每个场景写作完成后的上下文状态快照，用于为后续场景提供前情提要。

```sql
CREATE TABLE context_snapshots (
    id                      CHAR(36)        NOT NULL    COMMENT '主键 UUID',
    story_id                CHAR(36)        NOT NULL    COMMENT '所属故事 FK -> stories.id',
    manuscript_id           CHAR(36)        NULL        COMMENT '关联稿件 FK -> manuscripts.id',
    chapter_index           INT             NOT NULL    COMMENT '章节序号（从 0 开始）',
    scene_index             INT             NOT NULL    COMMENT '场景序号（从 0 开始）',
    active_characters_json  TEXT            NULL        COMMENT '当前场景活跃角色 JSON 数组',
    active_locations_json   TEXT            NULL        COMMENT '当前场景活跃地点 JSON 数组',
    timeline_position       VARCHAR(200)    NULL        COMMENT '时间线位置描述，如 "第三天黄昏"',
    summary                 TEXT            NULL        COMMENT 'AI 生成的场景摘要',
    emotional_tone          VARCHAR(100)    NULL        COMMENT '场景情感基调，如 "紧张、悬疑"',
    word_count              INT             NOT NULL DEFAULT 0
                                                        COMMENT '该场景字数',
    created_at              TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (id),
    INDEX idx_snapshot_story (story_id),
    INDEX idx_snapshot_chapter_scene (story_id, chapter_index, scene_index),
    CONSTRAINT fk_snapshot_story FOREIGN KEY (story_id) REFERENCES stories(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  COMMENT='场景上下文快照表';
```

##### 表 3：`entity_extractions` — 实体提取记录表

存储 AI 从稿件文本中自动提取的命名实体，支持人工审核流程。

```sql
CREATE TABLE entity_extractions (
    id              CHAR(36)        NOT NULL    COMMENT '主键 UUID',
    story_id        CHAR(36)        NOT NULL    COMMENT '所属故事 FK -> stories.id',
    manuscript_id   CHAR(36)        NULL        COMMENT '来源稿件 FK -> manuscripts.id',
    entity_name     VARCHAR(200)    NOT NULL    COMMENT '实体名称',
    entity_type     VARCHAR(50)     NOT NULL    COMMENT '实体类型: character/location/item/event/concept',
    attributes_json TEXT            NULL        COMMENT '实体属性 JSON，如 {"age":"25","gender":"男"}',
    source_text     TEXT            NULL        COMMENT '提取来源的原文片段',
    confidence      FLOAT           NOT NULL DEFAULT 0.0
                                                COMMENT 'AI 提取置信度 0.0-1.0',
    reviewed        TINYINT(1)      NOT NULL DEFAULT 0
                                                COMMENT '是否已人工审核',
    review_action   ENUM('pending','approved','rejected','merged')
                                    NOT NULL DEFAULT 'pending'
                                                COMMENT '审核动作',
    linked_lorebook_id CHAR(36)     NULL        COMMENT '关联的 Lorebook 条目（审核通过后）',
    created_at      TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (id),
    INDEX idx_extraction_story (story_id),
    INDEX idx_extraction_manuscript (manuscript_id),
    INDEX idx_extraction_type (story_id, entity_type),
    INDEX idx_extraction_review (story_id, reviewed),
    CONSTRAINT fk_extraction_story FOREIGN KEY (story_id) REFERENCES stories(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  COMMENT='AI 实体提取记录表';
```

#### 3.1.2 Neo4j 节点与关系

##### 节点类型定义

```cypher
// ========== 角色节点 ==========
CREATE (c:Character {
    id: 'uuid-char-001',
    name: '林逸',
    storyId: 'uuid-story-001',
    aliases: ['小逸', '逸哥', '林少侠'],
    description: '主角，天赋异禀的年轻剑修，性格沉稳内敛',
    firstAppearance: 0,    // 首次出现的章节索引
    status: 'active'       // active/deceased/absent
})

// ========== 地点节点 ==========
CREATE (l:Location {
    id: 'uuid-loc-001',
    name: '青云山',
    storyId: 'uuid-story-001',
    description: '青云宗所在的灵山，终年云雾缭绕',
    locationType: 'mountain',  // city/mountain/building/realm/other
    parentLocationId: null     // 支持地点层级关系
})

// ========== 事件节点 ==========
CREATE (e:Event {
    id: 'uuid-evt-001',
    name: '青云宗入门试炼',
    storyId: 'uuid-story-001',
    chapterIndex: 2,
    sceneIndex: 0,
    description: '林逸参加青云宗的入门试炼，展现出惊人的剑道天赋',
    eventType: 'milestone',    // milestone/conflict/revelation/transition
    timelinePosition: '第七天清晨'
})

// ========== 物品节点 ==========
CREATE (i:Item {
    id: 'uuid-item-001',
    name: '寒霜剑',
    storyId: 'uuid-story-001',
    description: '上古神兵，蕴含极寒之力，与林逸血脉共鸣',
    itemType: 'weapon',        // weapon/artifact/consumable/key_item
    significance: 'major'      // major/minor
})

// ========== 概念节点 ==========
CREATE (co:Concept {
    id: 'uuid-con-001',
    name: '剑道九境',
    storyId: 'uuid-story-001',
    description: '修仙世界的剑修境界体系：入门、通灵、凝气、筑基、金丹、元婴、化神、大乘、渡劫',
    conceptType: 'power_system' // power_system/faction/rule/lore
})
```

##### 关系类型定义

```cypher
// ========== 角色间关系 ==========
// KNOWS: 角色认识关系
CREATE (c1:Character {name:'林逸'})-[:KNOWS {
    since: 0,                          // 从第几章开始认识
    relationshipType: '师兄弟',         // 师徒/师兄弟/恋人/仇敌/盟友/亲属
    description: '同门师兄弟，关系亲近',
    sentiment: 'positive',              // positive/negative/neutral/complex
    lastInteractionChapter: 5
}]->(c2:Character {name:'苏瑶'})

// MENTORS: 师徒关系
CREATE (c3:Character {name:'玄清真人'})-[:MENTORS {
    since: 1,
    style: '严厉但关爱',
    status: 'active'                    // active/ended
}]->(c1:Character {name:'林逸'})

// RIVALS: 对手关系
CREATE (c1:Character {name:'林逸'})-[:RIVALS {
    since: 3,
    reason: '争夺入室弟子名额',
    intensity: 'high'                   // low/medium/high
}]->(c4:Character {name:'赵无极'})

// ========== 角色-地点关系 ==========
// LOCATED_AT: 角色在某地
CREATE (c1:Character {name:'林逸'})-[:LOCATED_AT {
    chapterIndex: 5,
    sceneIndex: 2,
    purpose: '修炼闭关'
}]->(l1:Location {name:'青云山'})

// ========== 角色-事件关系 ==========
// PARTICIPATES_IN: 角色参与事件
CREATE (c1:Character {name:'林逸'})-[:PARTICIPATES_IN {
    role: 'protagonist',                // protagonist/antagonist/witness/victim
    outcome: '通过试炼，被收为弟子'
}]->(e1:Event {name:'青云宗入门试炼'})

// ========== 角色-物品关系 ==========
// POSSESSES: 角色持有物品
CREATE (c1:Character {name:'林逸'})-[:POSSESSES {
    since: 4,                           // 从第几章开始持有
    acquisitionMethod: '机缘巧合获得',
    status: 'equipped'                  // equipped/stored/lost/destroyed
}]->(i1:Item {name:'寒霜剑'})

// ========== 事件-地点关系 ==========
// OCCURS_AT: 事件发生地
CREATE (e1:Event {name:'青云宗入门试炼'})-[:OCCURS_AT {
    specificLocation: '试炼广场'
}]->(l1:Location {name:'青云山'})

// ========== 事件因果链 ==========
// FOLLOWS: 事件先后顺序
CREATE (e1:Event {name:'青云宗入门试炼'})-[:FOLLOWS {
    causalRelation: 'enables',          // enables/causes/triggers/leads_to
    timeGap: '三个月后'
}]->(e2:Event {name:'外门弟子大比'})

// ========== 概念关联 ==========
// BELONGS_TO: 角色属于某概念体系
CREATE (c1:Character {name:'林逸'})-[:BELONGS_TO {
    level: '通灵境',
    rank: 2
}]->(co1:Concept {name:'剑道九境'})

// LOCATED_IN: 地点层级关系
CREATE (l2:Location {name:'藏剑阁'})-[:LOCATED_IN]->(l1:Location {name:'青云山'})
```

##### 常用查询模式

```cypher
// 查询某角色的 N 跳关系子图
MATCH path = (c:Character {storyId: $storyId, name: $entityName})-[*1..3]-(related)
RETURN path

// 查询某章节的所有活跃角色及其关系
MATCH (c:Character {storyId: $storyId})-[r:LOCATED_AT {chapterIndex: $chapter}]->(l:Location)
OPTIONAL MATCH (c)-[k:KNOWS]-(other:Character)
RETURN c, r, l, k, other

// 查询事件因果链
MATCH path = (e:Event {storyId: $storyId})-[:FOLLOWS*1..5]->(subsequent:Event)
WHERE e.name = $eventName
RETURN path ORDER BY length(path)

// 查询角色的完整时间线
MATCH (c:Character {storyId: $storyId, name: $charName})-[r]->(target)
RETURN type(r) AS relType, r, target
ORDER BY COALESCE(r.since, r.chapterIndex, 0)
```

#### 3.1.3 JSON 结构示例

##### Lorebook 条目 JSON

```json
{
  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "storyId": "story-uuid-001",
  "userId": "user-uuid-001",
  "entryKey": "青云宗",
  "displayName": "青云宗",
  "category": "location",
  "content": "青云宗是大陆五大宗门之一，坐落于青云山脉主峰。宗门以剑修闻名天下，传承万年不衰。宗内分为外门、内门、核心三个层级，拥有弟子三千余人。宗主为化神期强者玄天真人。宗门至宝为'青云剑阵'，可汇聚全宗弟子剑意形成绝世大阵。",
  "keywordsJson": ["青云宗", "青云山", "玄天真人", "青云剑阵", "五大宗门"],
  "priority": 10,
  "enabled": true,
  "insertionPosition": "before_scene",
  "tokenBudget": 500,
  "createdAt": "2026-02-17T10:00:00Z",
  "updatedAt": "2026-02-17T10:00:00Z"
}
```

##### 上下文快照 JSON

```json
{
  "id": "snap-uuid-001",
  "storyId": "story-uuid-001",
  "manuscriptId": "ms-uuid-001",
  "chapterIndex": 3,
  "sceneIndex": 2,
  "activeCharactersJson": [
    {
      "characterId": "char-uuid-001",
      "name": "林逸",
      "currentState": "受伤后恢复中",
      "emotionalState": "坚定但疲惫"
    },
    {
      "characterId": "char-uuid-002",
      "name": "苏瑶",
      "currentState": "守护在林逸身旁",
      "emotionalState": "担忧"
    }
  ],
  "activeLocationsJson": [
    {
      "locationId": "loc-uuid-003",
      "name": "青云宗·药庐",
      "description": "宗门疗伤之所"
    }
  ],
  "timelinePosition": "入宗后第三个月·深夜",
  "summary": "林逸在试炼中受重伤被送回药庐，苏瑶衣不解带地照顾。林逸在昏迷中感应到寒霜剑的共鸣，体内寒气开始自行疗伤。苏瑶发现林逸体表结霜，意识到他的体质异于常人。",
  "emotionalTone": "温情、悬疑",
  "wordCount": 3200,
  "createdAt": "2026-02-17T14:30:00Z"
}
```

##### 实体提取结果 JSON

```json
{
  "id": "ext-uuid-001",
  "storyId": "story-uuid-001",
  "manuscriptId": "ms-uuid-001",
  "entityName": "寒霜剑",
  "entityType": "item",
  "attributesJson": {
    "type": "weapon",
    "element": "ice",
    "origin": "上古神兵",
    "abilities": ["极寒之力", "血脉共鸣", "自主疗伤"],
    "currentOwner": "林逸"
  },
  "sourceText": "林逸感到腰间的寒霜剑微微震颤，一股极寒之力从剑身涌出，沿着经脉游走全身，所过之处伤口以肉眼可见的速度愈合。",
  "confidence": 0.92,
  "reviewed": false,
  "reviewAction": "pending",
  "linkedLorebookId": null,
  "createdAt": "2026-02-17T14:35:00Z"
}
```

### 3.2 后端设计

#### 包结构

```
backend/src/main/java/com/ainovel/app/context/
├── LorebookController.java          // Lorebook REST 端点
├── LorebookService.java             // Lorebook 业务逻辑
├── LorebookRepository.java          // JPA Repository
├── KnowledgeGraphService.java       // Neo4j 图谱操作
├── EntityExtractionService.java     // AI 实体提取
├── ContextAssemblyService.java      // 上下文组装（核心）
├── ContextSnapshotService.java      // 场景快照管理
├── ContextSnapshotRepository.java   // 快照 JPA Repository
├── EntityExtractionRepository.java  // 提取记录 JPA Repository
├── dto/
│   ├── LorebookEntryDto.java
│   ├── LorebookCreateRequest.java
│   ├── LorebookUpdateRequest.java
│   ├── LorebookImportRequest.java
│   ├── ContextSnapshotDto.java
│   ├── EntityExtractionDto.java
│   ├── EntityReviewRequest.java
│   ├── AssembledContext.java        // 组装后的上下文结果
│   ├── SubGraph.java                // Neo4j 子图查询结果
│   └── GraphQueryRequest.java
├── model/
│   ├── LorebookEntry.java           // JPA Entity
│   ├── ContextSnapshot.java         // JPA Entity
│   └── EntityExtraction.java        // JPA Entity
└── neo4j/
    ├── CharacterNode.java           // Neo4j @Node
    ├── LocationNode.java
    ├── EventNode.java
    ├── ItemNode.java
    ├── ConceptNode.java
    └── relationships/
        ├── KnowsRelationship.java   // Neo4j @RelationshipProperties
        ├── LocatedAtRelationship.java
        ├── ParticipatesInRelationship.java
        └── PossessesRelationship.java
```

#### 核心类与方法签名

##### ContextAssemblyService — 上下文组装服务（核心）

```java
package com.ainovel.app.context;

import com.ainovel.app.context.dto.AssembledContext;
import org.springframework.stereotype.Service;
import java.util.UUID;

/**
 * 上下文组装服务：在 AI 调用前，智能检索并组装最相关的上下文信息。
 * 这是整个上下文记忆系统的核心调度器。
 */
@Service
public class ContextAssemblyService {

    private final LorebookService lorebookService;
    private final KnowledgeGraphService knowledgeGraphService;
    private final ContextSnapshotService snapshotService;

    // 默认总 Token 预算
    private static final int DEFAULT_TOTAL_TOKEN_BUDGET = 4000;

    /**
     * 组装完整上下文，用于注入 AI Prompt。
     *
     * @param storyId       故事 ID
     * @param chapterIndex  当前章节索引
     * @param sceneIndex    当前场景索引
     * @param currentText   当前编辑器中的文本
     * @return AssembledContext 包含所有上下文片段和元数据
     */
    public AssembledContext assembleContext(
            UUID storyId,
            int chapterIndex,
            int sceneIndex,
            String currentText
    ) { /* ... */ }

    /**
     * 带自定义 Token 预算的上下文组装。
     */
    public AssembledContext assembleContext(
            UUID storyId,
            int chapterIndex,
            int sceneIndex,
            String currentText,
            int totalTokenBudget
    ) { /* ... */ }
}
```

##### AssembledContext — 组装结果 DTO

```java
package com.ainovel.app.context.dto;

import java.util.List;
import java.util.Map;

/**
 * AI Prompt 注入用的组装上下文。
 */
public record AssembledContext(
    /** 系统提示词级别的 Lorebook 条目 */
    List<LorebookFragment> systemPromptEntries,
    /** 场景前注入的 Lorebook 条目 */
    List<LorebookFragment> beforeSceneEntries,
    /** 场景后注入的 Lorebook 条目 */
    List<LorebookFragment> afterSceneEntries,
    /** 知识图谱中检索到的关系描述 */
    String graphRelationships,
    /** 最近 N 个场景的摘要 */
    List<String> recentSnapshots,
    /** 当前场景的活跃角色信息 */
    List<Map<String, String>> activeCharacters,
    /** 实际消耗的 Token 数估算 */
    int estimatedTokens,
    /** 总 Token 预算 */
    int totalBudget
) {
    public record LorebookFragment(
        String entryKey,
        String displayName,
        String category,
        String content,
        int priority,
        int estimatedTokens
    ) {}
}
```

##### EntityExtractionService — 实体提取服务

```java
package com.ainovel.app.context;

import com.ainovel.app.context.model.EntityExtraction;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.UUID;

@Service
public class EntityExtractionService {

    private final AiService aiService;
    private final EntityExtractionRepository extractionRepository;
    private final KnowledgeGraphService knowledgeGraphService;

    /**
     * 从文本中提取命名实体（同步调用，用于手动触发）。
     *
     * @param text    待提取的文本
     * @param storyId 所属故事 ID
     * @return 提取到的实体列表
     */
    public List<EntityExtraction> extractEntities(String text, UUID storyId) { /* ... */ }

    /**
     * 异步提取：在稿件保存后自动触发。
     *
     * @param text         稿件文本
     * @param storyId      故事 ID
     * @param manuscriptId 稿件 ID
     */
    @Async
    public void extractEntitiesAsync(String text, UUID storyId, UUID manuscriptId) { /* ... */ }

    /**
     * 审核实体提取结果。
     *
     * @param extractionId 提取记录 ID
     * @param action       审核动作: approved/rejected/merged
     * @param mergeTargetLorebookId 合并目标（当 action=merged 时）
     */
    public EntityExtraction reviewExtraction(
            UUID extractionId,
            String action,
            UUID mergeTargetLorebookId
    ) { /* ... */ }
}
```

##### KnowledgeGraphService — 知识图谱服务

```java
package com.ainovel.app.context;

import com.ainovel.app.context.dto.SubGraph;
import com.ainovel.app.context.model.EntityExtraction;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.UUID;

@Service
public class KnowledgeGraphService {

    private final Neo4jClient neo4jClient;

    /**
     * 将提取的实体同步到 Neo4j 图谱。
     * 对于已存在的节点执行 MERGE（更新属性），新节点执行 CREATE。
     *
     * @param storyId  故事 ID
     * @param entities 待同步的实体列表
     */
    public void syncToGraph(UUID storyId, List<EntityExtraction> entities) { /* ... */ }

    /**
     * 查询与指定实体相关的子图。
     *
     * @param entityName 实体名称
     * @param storyId    故事 ID
     * @param depth      查询深度（跳数），建议 1-3
     * @return SubGraph 包含节点和关系的子图
     */
    public SubGraph queryRelated(String entityName, UUID storyId, int depth) { /* ... */ }

    /**
     * 获取故事的完整图谱数据（用于前端可视化）。
     *
     * @param storyId 故事 ID
     * @return SubGraph 完整图谱
     */
    public SubGraph getFullGraph(UUID storyId) { /* ... */ }

    /**
     * 将子图关系转换为自然语言描述（用于 Prompt 注入）。
     *
     * @param subGraph 子图数据
     * @return 自然语言描述字符串
     */
    public String toNaturalLanguage(SubGraph subGraph) { /* ... */ }

    /**
     * 删除故事的所有图谱数据。
     */
    public void deleteStoryGraph(UUID storyId) { /* ... */ }
}
```

##### SubGraph — 子图查询结果 DTO

```java
package com.ainovel.app.context.dto;

import java.util.List;
import java.util.Map;

public record SubGraph(
    List<GraphNode> nodes,
    List<GraphEdge> edges
) {
    public record GraphNode(
        String id,
        String name,
        String type,       // Character/Location/Event/Item/Concept
        Map<String, Object> properties
    ) {}

    public record GraphEdge(
        String id,
        String sourceId,
        String targetId,
        String type,       // KNOWS/LOCATED_AT/PARTICIPATES_IN/...
        Map<String, Object> properties
    ) {}
}
```

##### ContextSnapshotService — 快照服务

```java
package com.ainovel.app.context;

import com.ainovel.app.context.dto.ContextSnapshotDto;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.UUID;

@Service
public class ContextSnapshotService {

    /**
     * 为指定场景生成上下文快照（AI 生成摘要）。
     */
    @Async
    public void generateSnapshot(
            UUID storyId,
            UUID manuscriptId,
            int chapterIndex,
            int sceneIndex,
            String sceneText
    ) { /* ... */ }

    /**
     * 获取最近 N 个场景的快照（用于前情提要）。
     */
    public List<ContextSnapshotDto> getRecentSnapshots(
            UUID storyId,
            int chapterIndex,
            int sceneIndex,
            int limit
    ) { /* ... */ }

    /**
     * 预览组装后的上下文（供前端展示）。
     */
    public AssembledContext previewContext(
            UUID storyId,
            int chapterIndex,
            int sceneIndex
    ) { /* ... */ }
}
```

#### 核心流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                        上下文记忆系统核心流程                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ① 用户在 TiptapEditor 中编写文本                                    │
│     │                                                               │
│  ② 用户点击"保存"或触发 AI 调用                                      │
│     │                                                               │
│     ├──→ [ContextAssemblyService.assembleContext()]                  │
│     │     │                                                         │
│     │     ├─ a) 提取当前文本中的关键词                                │
│     │     │                                                         │
│     │     ├─ b) LorebookService.findMatchingEntries()               │
│     │     │     → 关键词匹配 lorebook_entries                        │
│     │     │     → 按 priority DESC 排序                              │
│     │     │     → 在 token_budget 内截取                             │
│     │     │                                                         │
│     │     ├─ c) KnowledgeGraphService.queryRelated()                │
│     │     │     → 从 Neo4j 查询相关实体子图（2跳）                    │
│     │     │     → toNaturalLanguage() 转为文本描述                    │
│     │     │                                                         │
│     │     ├─ d) ContextSnapshotService.getRecentSnapshots()         │
│     │     │     → 获取前 3 个场景的摘要                               │
│     │     │                                                         │
│     │     └─ e) 组装 AssembledContext                                │
│     │           → 按 insertion_position 分组                         │
│     │           → 总 Token 不超过预算                                │
│     │                                                               │
│     ├──→ [AiService.chat()] 注入组装后的上下文                       │
│     │     → system_prompt 条目放入 system message                    │
│     │     → before_scene 条目 + 图谱关系 + 快照放入 context message  │
│     │     → 当前文本放入 user message                                │
│     │                                                               │
│  ③ AI 返回生成结果                                                   │
│     │                                                               │
│     ├──→ [EntityExtractionService.extractEntitiesAsync()]           │
│     │     → AI 从新文本中提取实体                                     │
│     │     → 存入 entity_extractions 表（reviewed=false）             │
│     │                                                               │
│     ├──→ [ContextSnapshotService.generateSnapshot()]                │
│     │     → AI 生成场景摘要                                          │
│     │     → 存入 context_snapshots 表                                │
│     │                                                               │
│     └──→ [KnowledgeGraphService.syncToGraph()]                      │
│           → 已审核通过的实体同步到 Neo4j                              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 API 设计

所有 v2 API 统一前缀 `/api/v2`，遵循现有 `spring.mvc.servlet.path=/api` 配置。

#### 3.3.1 Lorebook CRUD

##### GET /v2/stories/{storyId}/lorebook — 获取 Lorebook 条目列表

请求参数（Query）：
```
?category=character&enabled=true&keyword=林逸&page=0&size=20
```

响应 200：
```json
{
  "content": [
    {
      "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      "storyId": "story-uuid-001",
      "entryKey": "林逸",
      "displayName": "林逸 - 主角",
      "category": "character",
      "content": "林逸，男，二十岁，天赋异禀的年轻剑修...",
      "keywordsJson": ["林逸", "小逸", "逸哥", "林少侠"],
      "priority": 20,
      "enabled": true,
      "insertionPosition": "before_scene",
      "tokenBudget": 600,
      "createdAt": "2026-02-17T10:00:00Z",
      "updatedAt": "2026-02-17T10:00:00Z"
    }
  ],
  "totalElements": 15,
  "totalPages": 1,
  "number": 0,
  "size": 20
}
```

错误码：
- `404` — 故事不存在
- `403` — 无权访问该故事

##### POST /v2/stories/{storyId}/lorebook — 创建 Lorebook 条目

请求体：
```json
{
  "entryKey": "青云宗",
  "displayName": "青云宗",
  "category": "location",
  "content": "青云宗是大陆五大宗门之一，坐落于青云山脉主峰...",
  "keywordsJson": ["青云宗", "青云山", "玄天真人"],
  "priority": 10,
  "insertionPosition": "before_scene",
  "tokenBudget": 500
}
```

响应 201：
```json
{
  "id": "new-uuid-001",
  "storyId": "story-uuid-001",
  "entryKey": "青云宗",
  "displayName": "青云宗",
  "category": "location",
  "content": "青云宗是大陆五大宗门之一，坐落于青云山脉主峰...",
  "keywordsJson": ["青云宗", "青云山", "玄天真人"],
  "priority": 10,
  "enabled": true,
  "insertionPosition": "before_scene",
  "tokenBudget": 500,
  "createdAt": "2026-02-17T10:30:00Z",
  "updatedAt": "2026-02-17T10:30:00Z"
}
```

错误码：
- `400` — 参数校验失败（entryKey 为空、content 为空等）
- `404` — 故事不存在
- `409` — 同一故事下 entryKey 重复

##### PUT /v2/stories/{storyId}/lorebook/{entryId} — 更新 Lorebook 条目

请求体：
```json
{
  "displayName": "青云宗（已更新）",
  "content": "青云宗是大陆五大宗门之首...",
  "keywordsJson": ["青云宗", "青云山", "玄天真人", "青云剑阵"],
  "priority": 15,
  "enabled": true,
  "insertionPosition": "system_prompt",
  "tokenBudget": 800
}
```

响应 200：返回更新后的完整条目 JSON（同创建响应格式）。

错误码：
- `404` — 条目不存在
- `403` — 无权修改

##### DELETE /v2/stories/{storyId}/lorebook/{entryId} — 删除 Lorebook 条目

响应 204：无内容。

错误码：
- `404` — 条目不存在

##### POST /v2/stories/{storyId}/lorebook/import — 批量导入 Lorebook 条目

请求体：
```json
{
  "entries": [
    {
      "entryKey": "剑道九境",
      "displayName": "剑道九境 - 修炼体系",
      "category": "concept",
      "content": "剑修的九个境界：入门、通灵、凝气、筑基、金丹、元婴、化神、大乘、渡劫。每个境界分为初期、中期、后期、巅峰四个小阶段。",
      "keywordsJson": ["剑道九境", "境界", "修炼", "突破"],
      "priority": 5,
      "insertionPosition": "before_scene",
      "tokenBudget": 400
    },
    {
      "entryKey": "灵石货币",
      "displayName": "灵石货币体系",
      "category": "concept",
      "content": "修仙界通用货币为灵石，分为下品、中品、上品、极品四个等级...",
      "keywordsJson": ["灵石", "货币", "交易"],
      "priority": 3,
      "insertionPosition": "before_scene",
      "tokenBudget": 300
    }
  ],
  "overwriteExisting": false
}
```

响应 200：
```json
{
  "imported": 2,
  "skipped": 0,
  "errors": []
}
```

错误码：
- `400` — entries 数组为空或超过 100 条限制
- `413` — 请求体过大

#### 3.3.2 Knowledge Graph API

##### GET /v2/stories/{storyId}/graph — 获取完整图谱数据

响应 200：
```json
{
  "nodes": [
    {
      "id": "uuid-char-001",
      "name": "林逸",
      "type": "Character",
      "properties": {
        "aliases": ["小逸", "逸哥"],
        "description": "主角，天赋异禀的年轻剑修",
        "status": "active",
        "firstAppearance": 0
      }
    },
    {
      "id": "uuid-loc-001",
      "name": "青云山",
      "type": "Location",
      "properties": {
        "description": "青云宗所在的灵山",
        "locationType": "mountain"
      }
    }
  ],
  "edges": [
    {
      "id": "edge-001",
      "sourceId": "uuid-char-001",
      "targetId": "uuid-char-002",
      "type": "KNOWS",
      "properties": {
        "since": 0,
        "relationshipType": "师兄弟",
        "sentiment": "positive"
      }
    },
    {
      "id": "edge-002",
      "sourceId": "uuid-char-001",
      "targetId": "uuid-loc-001",
      "type": "LOCATED_AT",
      "properties": {
        "chapterIndex": 5,
        "purpose": "修炼闭关"
      }
    }
  ],
  "stats": {
    "totalNodes": 24,
    "totalEdges": 38,
    "nodesByType": {
      "Character": 8,
      "Location": 6,
      "Event": 5,
      "Item": 3,
      "Concept": 2
    }
  }
}
```

错误码：
- `404` — 故事不存在
- `503` — Neo4j 连接不可用

##### GET /v2/stories/{storyId}/graph/query — 查询子图

请求参数（Query）：
```
?entity=林逸&depth=2
```

响应 200：
```json
{
  "centerNode": {
    "id": "uuid-char-001",
    "name": "林逸",
    "type": "Character"
  },
  "nodes": [ /* 同完整图谱格式 */ ],
  "edges": [ /* 同完整图谱格式 */ ],
  "naturalLanguageDescription": "林逸是青云宗弟子，师从玄清真人。与苏瑶是同门师兄妹关系（亲近），与赵无极是竞争对手关系（紧张）。目前位于青云山修炼闭关。持有上古神兵寒霜剑。参与了青云宗入门试炼（通过）和外门弟子大比（获胜）。"
}
```

错误码：
- `400` — entity 参数为空
- `404` — 实体在图谱中不存在

##### POST /v2/stories/{storyId}/graph/sync — 手动触发图谱同步

请求体：
```json
{
  "scope": "full",
  "forceReindex": false
}
```

响应 202：
```json
{
  "taskId": "task-uuid-001",
  "status": "processing",
  "message": "图谱同步任务已提交，预计耗时 30 秒"
}
```

错误码：
- `409` — 已有同步任务在执行中
- `503` — Neo4j 不可用

#### 3.3.3 Entity Extraction API

##### POST /v2/stories/{storyId}/extract-entities — 从文本提取实体

请求体：
```json
{
  "text": "林逸感到腰间的寒霜剑微微震颤，一股极寒之力从剑身涌出...",
  "manuscriptId": "ms-uuid-001"
}
```

响应 200：
```json
{
  "extractions": [
    {
      "id": "ext-uuid-001",
      "entityName": "林逸",
      "entityType": "character",
      "attributesJson": {
        "role": "protagonist",
        "currentAction": "感应到寒霜剑共鸣"
      },
      "sourceText": "林逸感到腰间的寒霜剑微微震颤",
      "confidence": 0.95,
      "reviewed": false,
      "reviewAction": "pending"
    },
    {
      "id": "ext-uuid-002",
      "entityName": "寒霜剑",
      "entityType": "item",
      "attributesJson": {
        "type": "weapon",
        "element": "ice",
        "abilities": ["极寒之力", "自主震颤"]
      },
      "sourceText": "寒霜剑微微震颤，一股极寒之力从剑身涌出",
      "confidence": 0.92,
      "reviewed": false,
      "reviewAction": "pending"
    }
  ],
  "totalExtracted": 2
}
```

错误码：
- `400` — text 为空
- `429` — AI 调用频率限制
- `502` — AI 服务不可用

##### GET /v2/stories/{storyId}/extractions — 获取待审核提取列表

请求参数（Query）：
```
?reviewed=false&entityType=character&page=0&size=20
```

响应 200：
```json
{
  "content": [
    {
      "id": "ext-uuid-001",
      "entityName": "林逸",
      "entityType": "character",
      "attributesJson": { "role": "protagonist" },
      "sourceText": "林逸感到腰间的寒霜剑微微震颤",
      "confidence": 0.95,
      "reviewed": false,
      "reviewAction": "pending",
      "manuscriptId": "ms-uuid-001",
      "createdAt": "2026-02-17T14:35:00Z"
    }
  ],
  "totalElements": 8,
  "totalPages": 1
}
```

##### PUT /v2/stories/{storyId}/extractions/{id}/review — 审核实体提取

请求体：
```json
{
  "action": "approved",
  "mergeTargetLorebookId": null,
  "createLorebookEntry": true,
  "lorebookOverrides": {
    "displayName": "林逸 - 主角",
    "priority": 20,
    "tokenBudget": 600
  }
}
```

响应 200：
```json
{
  "id": "ext-uuid-001",
  "entityName": "林逸",
  "entityType": "character",
  "reviewed": true,
  "reviewAction": "approved",
  "linkedLorebookId": "lorebook-uuid-new",
  "graphNodeSynced": true
}
```

错误码：
- `400` — action 值无效
- `404` — 提取记录不存在
- `409` — 已审核过的记录不可重复审核

#### 3.3.4 Context Preview API

##### GET /v2/stories/{storyId}/context/preview — 预览组装上下文

请求参数（Query）：
```
?chapter=3&scene=2&tokenBudget=4000
```

响应 200：
```json
{
  "systemPromptEntries": [
    {
      "entryKey": "世界观总纲",
      "displayName": "世界观总纲",
      "category": "concept",
      "content": "本故事设定在一个修仙世界...",
      "priority": 100,
      "estimatedTokens": 350
    }
  ],
  "beforeSceneEntries": [
    {
      "entryKey": "林逸",
      "displayName": "林逸 - 主角",
      "category": "character",
      "content": "林逸，男，二十岁...",
      "priority": 20,
      "estimatedTokens": 280
    },
    {
      "entryKey": "青云宗",
      "displayName": "青云宗",
      "category": "location",
      "content": "青云宗是大陆五大宗门之一...",
      "priority": 10,
      "estimatedTokens": 200
    }
  ],
  "afterSceneEntries": [],
  "graphRelationships": "林逸与苏瑶是同门师兄妹（关系亲近）。林逸师从玄清真人。林逸目前位于青云山药庐。林逸持有寒霜剑。",
  "recentSnapshots": [
    "【第3章·场景1】林逸在试炼场与赵无极对决，使出寒霜剑法，但因境界不足落入下风...",
    "【第3章·场景0】外门弟子大比开幕，各方势力齐聚试炼广场..."
  ],
  "activeCharacters": [
    {"name": "林逸", "currentState": "受伤后恢复中"},
    {"name": "苏瑶", "currentState": "守护在林逸身旁"}
  ],
  "estimatedTokens": 2850,
  "totalBudget": 4000
}
```

错误码：
- `404` — 故事不存在或章节/场景索引越界

### 3.4 前端设计

#### 3.4.1 组件架构

所有新组件集成到现有 Workbench 页面（`frontend/src/pages/Workbench/Workbench.tsx`），作为新的 Tab 页签。

```
frontend/src/pages/Workbench/
├── Workbench.tsx                          // 新增 "知识库" 和 "知识图谱" Tab
├── tabs/
│   ├── ManuscriptWriter.tsx               // 现有 - 新增 ContextPreviewPanel 集成
│   ├── LorebookPanel.tsx                  // 新增 - Lorebook 管理面板
│   ├── KnowledgeGraphTab.tsx              // 新增 - 知识图谱可视化 Tab
│   └── ...
└── components/
    ├── lorebook/
    │   ├── LorebookEntryList.tsx           // 条目列表（可筛选、搜索）
    │   ├── LorebookEntryEditor.tsx         // 条目编辑表单
    │   ├── LorebookImportDialog.tsx        // 批量导入对话框
    │   └── LorebookCategoryBadge.tsx       // 类别标签组件
    ├── graph/
    │   ├── KnowledgeGraphViewer.tsx        // react-force-graph 图谱可视化
    │   ├── GraphControls.tsx              // 缩放、过滤、搜索控件
    │   └── NodeDetailPopover.tsx          // 节点详情弹出框
    ├── extraction/
    │   ├── EntityExtractionReview.tsx      // 实体审核面板
    │   └── ExtractionBadge.tsx            // 提取状态标签
    └── context/
        └── ContextPreviewPanel.tsx         // 上下文预览面板
```

#### 3.4.2 LorebookPanel — Lorebook 管理面板

集成位置：Workbench TabsList 新增 "知识库" Tab。

```tsx
// LorebookPanel.tsx 核心结构
interface LorebookPanelProps {
  storyId: string;
}

const LorebookPanel = ({ storyId }: LorebookPanelProps) => {
  const [entries, setEntries] = useState<LorebookEntry[]>([]);
  const [selectedEntry, setSelectedEntry] = useState<LorebookEntry | null>(null);
  const [filterCategory, setFilterCategory] = useState<string>("all");
  const [searchKeyword, setSearchKeyword] = useState("");
  const [isImportOpen, setIsImportOpen] = useState(false);

  return (
    <ResizablePanelGroup direction="horizontal">
      {/* 左侧：条目列表 */}
      <ResizablePanel defaultSize={40}>
        <div className="flex flex-col h-full">
          {/* 搜索栏 + 筛选 + 新建按钮 */}
          <div className="flex gap-2 p-3 border-b">
            <Input placeholder="搜索条目..." value={searchKeyword}
                   onChange={e => setSearchKeyword(e.target.value)} />
            <Select value={filterCategory} onValueChange={setFilterCategory}>
              <SelectTrigger className="w-32">
                <SelectValue placeholder="全部类别" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">全部</SelectItem>
                <SelectItem value="character">角色</SelectItem>
                <SelectItem value="location">地点</SelectItem>
                <SelectItem value="item">物品</SelectItem>
                <SelectItem value="event">事件</SelectItem>
                <SelectItem value="concept">概念</SelectItem>
                <SelectItem value="custom">自定义</SelectItem>
              </SelectContent>
            </Select>
            <Button size="sm" onClick={() => setSelectedEntry(newEmptyEntry())}>
              <Plus className="h-4 w-4" />
            </Button>
            <Button size="sm" variant="outline" onClick={() => setIsImportOpen(true)}>
              <Upload className="h-4 w-4" />
            </Button>
          </div>
          {/* 条目列表 */}
          <ScrollArea className="flex-1">
            <LorebookEntryList
              entries={filteredEntries}
              selectedId={selectedEntry?.id}
              onSelect={setSelectedEntry}
            />
          </ScrollArea>
        </div>
      </ResizablePanel>

      <ResizableHandle />

      {/* 右侧：条目编辑器 */}
      <ResizablePanel defaultSize={60}>
        {selectedEntry ? (
          <LorebookEntryEditor
            entry={selectedEntry}
            onSave={handleSave}
            onDelete={handleDelete}
          />
        ) : (
          <EmptyState message="选择或创建一个条目开始编辑" />
        )}
      </ResizablePanel>

      {/* 导入对话框 */}
      <LorebookImportDialog
        open={isImportOpen}
        onOpenChange={setIsImportOpen}
        storyId={storyId}
        onImported={refreshEntries}
      />
    </ResizablePanelGroup>
  );
};
```

#### 3.4.3 LorebookEntryEditor — 条目编辑器

```tsx
interface LorebookEntryEditorProps {
  entry: LorebookEntry;
  onSave: (entry: LorebookEntry) => Promise<void>;
  onDelete: (id: string) => Promise<void>;
}

const LorebookEntryEditor = ({ entry, onSave, onDelete }: LorebookEntryEditorProps) => {
  // 表单字段：
  // - displayName (Input)
  // - entryKey (Input)
  // - category (Select: character/location/item/event/concept/custom)
  // - content (Textarea, 支持 Markdown)
  // - keywords (TagInput, 可添加/删除关键词标签)
  // - priority (Slider 0-100)
  // - insertionPosition (RadioGroup: before_scene/after_scene/system_prompt)
  // - tokenBudget (NumberInput, 显示当前 content 的估算 Token 数)
  // - enabled (Switch)
  //
  // 底部操作栏：
  // - [保存] 按钮
  // - [删除] 按钮（带确认对话框）
  // - Token 估算实时显示："当前内容约 XXX tokens / 预算 XXX tokens"
};
```

#### 3.4.4 KnowledgeGraphViewer — 知识图谱可视化

集成位置：Workbench TabsList 新增 "知识图谱" Tab。

使用 `react-force-graph-2d` 库实现交互式图谱可视化。

```tsx
interface KnowledgeGraphViewerProps {
  storyId: string;
}

const KnowledgeGraphViewer = ({ storyId }: KnowledgeGraphViewerProps) => {
  const [graphData, setGraphData] = useState<{ nodes: GraphNode[]; links: GraphEdge[] }>({
    nodes: [], links: []
  });
  const [selectedNode, setSelectedNode] = useState<GraphNode | null>(null);
  const [filterTypes, setFilterTypes] = useState<Set<string>>(
    new Set(["Character", "Location", "Event", "Item", "Concept"])
  );
  const [searchEntity, setSearchEntity] = useState("");
  const [queryDepth, setQueryDepth] = useState(2);
  const graphRef = useRef<any>();

  // 节点颜色映射（sage green 色系）
  const nodeColors: Record<string, string> = {
    Character: "#5B7F67",   // 深鼠尾草绿
    Location: "#6B8FA3",    // 灰蓝
    Event: "#D4A574",       // 暖棕
    Item: "#7FA88E",        // 浅鼠尾草绿
    Concept: "#8B6F4E",     // 深棕
  };

  return (
    <div className="flex h-full">
      {/* 左侧控制面板 */}
      <div className="w-64 border-r p-4 flex flex-col gap-4">
        <GraphControls
          filterTypes={filterTypes}
          onFilterChange={setFilterTypes}
          searchEntity={searchEntity}
          onSearchChange={setSearchEntity}
          queryDepth={queryDepth}
          onDepthChange={setQueryDepth}
          onRefresh={() => fetchGraphData()}
          onFitView={() => graphRef.current?.zoomToFit(400)}
        />
        {/* 图谱统计 */}
        <div className="text-sm text-muted-foreground">
          节点: {graphData.nodes.length} / 关系: {graphData.links.length}
        </div>
      </div>

      {/* 中央图谱画布 */}
      <div className="flex-1 relative">
        <ForceGraph2D
          ref={graphRef}
          graphData={filteredGraphData}
          nodeLabel="name"
          nodeColor={node => nodeColors[node.type] || "#6b7280"}
          nodeRelSize={6}
          nodeVal={node => Math.max(8, Math.min(32, (node.connections ?? 1) * 4))}
          nodeCanvasObject={(node, ctx, globalScale) => {
            // 根据类型绘制不同形状：Circle / Hexagon / Diamond / Square / Triangle
            drawNodeByType(node, ctx, globalScale, nodeColors, selectedNode, searchEntity);
          }}
          linkLabel={link => link.type}
          linkDirectionalArrowLength={4}
          linkColor={() => "#94a3b8"}
          onNodeClick={(node) => setSelectedNode(node)}
          onNodeRightClick={(node, event) => openNodeContextMenu(node, event)}
          onNodeDrag={(node) => handleNodeDrag(node)}
          onNodeDragEnd={(node) => handleNodeDragEnd(node)}
          onLinkClick={(link) => setSelectedEdge(link)}
          onLinkRightClick={(link, event) => openEdgeContextMenu(link, event)}
          onBackgroundClick={() => { setSelectedNode(null); setSelectedEdge(null); }}
          enableZoomInteraction={true}
          enablePanInteraction={true}
          enableNodeDrag={true}
        />

        {/* 节点详情弹出框 */}
        {selectedNode && (
          <NodeDetailPopover
            node={selectedNode}
            onClose={() => setSelectedNode(null)}
            onNavigateToLorebook={(entryKey) => {
              // 双击节点时跳转到 Lorebook 对应条目
              navigateToLorebookEntry(storyId, entryKey);
            }}
          />
        )}
      </div>
    </div>
  );
};
```

**交互规范说明：**

**节点交互（Node Interaction）：**

| 操作 | 触发方式 | 行为 |
|------|----------|------|
| 选中节点 | 单击节点 | 高亮选中节点，右侧弹出 `NodeDetailPopover` 显示节点属性详情 |
| 跳转 Lorebook | 双击节点 | 调用 `navigateToLorebookEntry(storyId, entryKey)` 跳转到对应 Lorebook 条目编辑页 |
| 上下文菜单 | 右键点击节点 | 弹出菜单：「编辑属性」「删除节点」「添加关系」「在 Lorebook 中查看」 |
| 拖拽重定位 | 按住节点拖动 | 节点跟随鼠标移动，松开后固定在新位置；力导向布局暂停直到松开 |
| 创建关系 | 从节点边缘拖出 | 拖拽到目标节点后松开，弹出关系类型选择对话框 |

**边交互（Edge Interaction）：**

| 操作 | 触发方式 | 行为 |
|------|----------|------|
| 查看标签 | 鼠标悬停在边上 | 显示 tooltip，内容为关系类型标签（如「师徒」「位于」） |
| 选中边 | 单击边 | 高亮选中边，底部状态栏显示关系详情（源节点 → 关系类型 → 目标节点） |
| 编辑/删除 | 右键点击边 | 弹出菜单：「编辑关系类型」「删除关系」 |

**画布交互（Canvas Interaction）：**

| 操作 | 触发方式 | 行为 |
|------|----------|------|
| 缩放 | 鼠标滚轮 | 以鼠标位置为中心缩放画布，缩放范围 0.1x ~ 5x |
| 平移 | 拖拽空白区域 | 平移整个画布视图 |
| 触屏缩放 | 双指捏合（触摸设备） | 以捏合中心为基准缩放画布 |
| 取消选中 | 单击空白区域 | 清除当前选中的节点和边 |
| 适应视图 | 点击控制面板「适应视图」按钮 | 调用 `graphRef.current.zoomToFit(400)` 自动缩放至全部节点可见 |

**搜索交互（Search）：**

在左侧控制面板搜索框中输入关键词时：
- 匹配节点：添加 **脉冲动画**（`pulse` CSS animation），节点外圈以 `rgba(91,127,103,0.6)` 颜色每 1.2s 扩散一次
- 非匹配节点：透明度降低至 **30%**（`opacity: 0.3`），过渡动画 300ms ease-out
- 非匹配边：透明度降低至 **15%**
- 清空搜索框时，所有节点/边恢复至 100% 透明度，过渡动画 200ms ease-in

**筛选交互（Filter）：**

左侧控制面板中每种实体类型对应一个 checkbox：
- 取消勾选某类型 → 该类型所有节点及其关联边以 **淡出动画**（300ms fade-out）隐藏
- 重新勾选 → 以 **淡入动画**（300ms fade-in）恢复显示
- 筛选状态持久化到组件 state，刷新图谱数据时保留筛选条件

#### 3.4.5 图谱节点视觉规范

不同实体类型使用不同的几何形状和颜色，便于用户快速区分节点类别。

**节点形状映射：**

| 实体类型 | 形状 | 说明 |
|----------|------|------|
| Character（角色） | 圆形（Circle） | 最常见的实体类型，圆形便于识别 |
| Location（地点） | 六边形（Hexagon） | 六边形暗示空间/区域概念 |
| Event（事件） | 菱形（Diamond） | 菱形表示时间节点/转折 |
| Item（物品） | 正方形（Square） | 方形表示具体实物 |
| Concept（概念） | 三角形（Triangle） | 三角形表示抽象概念 |

**节点颜色方案（Sage Green 色系）：**

| 实体类型 | 色值 | 色名 |
|----------|------|------|
| Character | `#5B7F67` | 深鼠尾草绿 |
| Location | `#6B8FA3` | 灰蓝 |
| Event | `#D4A574` | 暖棕 |
| Item | `#7FA88E` | 浅鼠尾草绿 |
| Concept | `#8B6F4E` | 深棕 |

**节点尺寸规则：**

节点大小与其连接数（degree）成正比，计算公式：

```
nodeSize = clamp(baseSize + connectionCount * scaleFactor, minSize, maxSize)
```

- `minSize`：8px — 孤立节点或连接数极少的节点
- `maxSize`：32px — 核心枢纽节点（如主角、主要地点）
- `baseSize`：8px
- `scaleFactor`：4px / connection

**节点状态视觉效果：**

| 状态 | 视觉效果 | 实现方式 |
|------|----------|----------|
| 默认 | 实体类型对应颜色填充 + 1px 深色描边 | `ctx.fill()` + `ctx.stroke()` |
| 悬停 | 亮度提升 15%，显示名称标签 | `filter: brightness(1.15)` |
| 选中 | 外圈发光环效果，颜色为节点色 40% 透明度，半径为节点尺寸 + 6px | `ctx.shadowBlur = 12; ctx.shadowColor = nodeColor` |
| 搜索命中 | 脉冲动画：外圈以 `rgba(91,127,103,0.6)` 每 1.2s 扩散一次 | `requestAnimationFrame` 循环绘制扩散圆环 |
| 被筛选隐藏 | 300ms fade-out 后从画布移除 | `opacity` 过渡 + `display: none` |

#### 3.4.6 图谱编辑交互

图谱支持直接在画布上进行节点和关系的增删改操作，所有变更实时同步到 Lorebook 和 Neo4j。

**内联编辑（Inline Editing）：**

单击选中节点后，右侧弹出 `NodeDetailPopover`，包含可编辑表单：

```tsx
interface NodeEditPopoverProps {
  node: GraphNode;
  onSave: (updated: GraphNode) => Promise<void>;
  onClose: () => void;
}

// Popover 内容：
// - 名称输入框（必填）
// - 类型下拉选择：Character / Location / Event / Item / Concept
// - 属性键值对编辑器（动态增删行）
// - [保存] 按钮 → 调用 PUT /v2/stories/{storyId}/lorebook/entries/{entryKey}
// - [取消] 按钮 → 关闭 Popover，丢弃未保存的修改
```

**关系创建（Relationship Creation）：**

从源节点边缘拖出连线到目标节点的交互流程：

1. 用户按住源节点边缘区域开始拖拽，画布显示一条跟随鼠标的虚线
2. 虚线悬停到有效目标节点时，目标节点高亮显示（边框变为 `#5B7F67` 2px 实线）
3. 松开鼠标后弹出「关系类型选择对话框」：
   - 预设关系类型下拉列表（师徒、父子、位于、拥有、参与、触发、相关等）
   - 自定义关系类型输入框
   - 关系方向切换（A→B / B→A / 双向）
   - [确认] → 调用 `POST /v2/stories/{storyId}/knowledge-graph/relationships`
   - [取消] → 丢弃操作
4. 创建成功后，新边以淡入动画出现在画布上

**删除操作（Deletion）：**

- 右键点击节点 → 上下文菜单中选择「删除节点」→ 弹出确认对话框：
  - 提示文案：「确定删除节点「{nodeName}」及其所有关联关系吗？此操作将同步删除 Lorebook 中的对应条目。」
  - [确认删除] → 调用 `DELETE /v2/stories/{storyId}/lorebook/entries/{entryKey}`，同时删除 Neo4j 中的节点及关联边
  - [取消] → 关闭对话框
- 右键点击边 → 上下文菜单中选择「删除关系」→ 弹出确认对话框：
  - 提示文案：「确定删除「{sourceNode}」→「{relationType}」→「{targetNode}」关系吗？」
  - [确认删除] → 调用 `DELETE /v2/stories/{storyId}/knowledge-graph/relationships/{relationshipId}`
  - [取消] → 关闭对话框

**数据同步机制：**

所有图谱编辑操作通过以下 API 端点同步到后端：

| 操作 | API 端点 | 同步目标 |
|------|----------|----------|
| 编辑节点属性 | `PUT /v2/stories/{storyId}/lorebook/entries/{entryKey}` | Lorebook + Neo4j |
| 创建关系 | `POST /v2/stories/{storyId}/knowledge-graph/relationships` | Neo4j + Lorebook 关联字段 |
| 删除节点 | `DELETE /v2/stories/{storyId}/lorebook/entries/{entryKey}` | Lorebook + Neo4j（级联删除关联边） |
| 删除关系 | `DELETE /v2/stories/{storyId}/knowledge-graph/relationships/{id}` | Neo4j + Lorebook 关联字段 |

编辑操作采用乐观更新策略：先在前端立即反映变更，后台异步调用 API；若 API 返回失败则回滚前端状态并显示错误提示。

#### 3.4.7 EntityExtractionReview — 实体审核面板

集成位置：LorebookPanel 内的子 Tab 或独立面板。

```tsx
interface EntityExtractionReviewProps {
  storyId: string;
}

const EntityExtractionReview = ({ storyId }: EntityExtractionReviewProps) => {
  // 展示待审核的实体提取列表
  // 每条记录显示：
  //   - 实体名称 + 类型标签
  //   - 置信度进度条
  //   - 来源文本片段（高亮实体名称）
  //   - 提取的属性 JSON（可折叠）
  //   - 操作按钮：[通过] [拒绝] [合并到已有条目]
  //
  // 批量操作：
  //   - [全部通过高置信度 (>0.9)]
  //   - [全部拒绝低置信度 (<0.5)]
};
```

#### 3.4.8 ContextPreviewPanel — 上下文预览面板

集成位置：ManuscriptWriter 的 CopilotSidebar 内新增 "上下文" Tab。

```tsx
interface ContextPreviewPanelProps {
  storyId: string;
  chapterIndex: number;
  sceneIndex: number;
}

const ContextPreviewPanel = ({ storyId, chapterIndex, sceneIndex }: ContextPreviewPanelProps) => {
  // 调用 GET /v2/stories/{storyId}/context/preview
  // 展示：
  //   - Token 使用量可视化（进度条：已用/总预算）
  //   - 分区折叠面板：
  //     - [System Prompt 条目] — 展示注入到 system message 的条目
  //     - [场景前条目] — 展示 before_scene 条目
  //     - [图谱关系] — 展示自然语言描述的关系
  //     - [前情摘要] — 展示最近场景的摘要
  //     - [活跃角色] — 展示当前场景的角色状态
  //   - 每个条目显示预估 Token 数
  //   - [刷新] 按钮重新组装预览
};
```

#### 3.4.9 Workbench 集成改动

在现有 `Workbench.tsx` 中新增两个 Tab：

```tsx
// Workbench.tsx 改动示意
import LorebookPanel from "./tabs/LorebookPanel";
import KnowledgeGraphTab from "./tabs/KnowledgeGraphTab";
import { BookOpen, Network } from "lucide-react";

// TabsList 从 grid-cols-5 改为 grid-cols-7
<TabsList className="grid w-full grid-cols-7 lg:w-[1100px]">
  {/* ...现有 5 个 Tab... */}
  <TabsTrigger value="lorebook" className="gap-2">
    <BookOpen className="h-4 w-4" /> 知识库
  </TabsTrigger>
  <TabsTrigger value="graph" className="gap-2">
    <Network className="h-4 w-4" /> 知识图谱
  </TabsTrigger>
</TabsList>

// 新增 TabsContent
<TabsContent value="lorebook" className="h-full m-0 border-0 p-0">
  <LorebookPanel storyId={storyId} />
</TabsContent>
<TabsContent value="graph" className="h-full m-0 border-0 p-0">
  <KnowledgeGraphTab storyId={storyId} />
</TabsContent>
```

### 3.5 Prompt 工程

#### 3.5.1 实体提取 Prompt 模板

```
你是一个专业的小说实体提取专家。请从以下小说文本中提取所有命名实体，并以 JSON 格式返回。

## 提取规则

1. 提取以下类型的实体：
   - character（角色）：人物名称、称号、绰号
   - location（地点）：地名、建筑名、区域名
   - item（物品）：武器、法宝、道具、重要物件
   - event（事件）：重要事件、战斗、仪式、转折点
   - concept（概念）：功法、境界、阵法、规则、势力名称

2. 对每个实体提取以下信息：
   - entityName：实体的标准名称
   - entityType：实体类型（character/location/item/event/concept）
   - attributes：实体属性（JSON 对象，根据类型不同包含不同字段）
   - sourceText：提取该实体的原文片段（不超过 100 字）
   - confidence：你对这个提取结果的置信度（0.0-1.0）

3. 属性字段参考：
   - character: {gender, age, role, affiliation, abilities, currentState}
   - location: {locationType, parentLocation, features}
   - item: {itemType, element, abilities, currentOwner}
   - event: {eventType, participants, outcome, significance}
   - concept: {conceptType, scope, rules}

4. 注意事项：
   - 只提取文本中明确提到的实体，不要推测
   - 如果同一实体有多个称呼，使用最正式的名称作为 entityName
   - 代词（他、她、它）不算实体
   - 置信度低于 0.5 的实体不要返回

## 待提取文本

{text}

## 输出格式

请严格按以下 JSON 格式返回，不要包含其他文字：

```json
{
  "entities": [
    {
      "entityName": "实体名称",
      "entityType": "character",
      "attributes": {
        "gender": "男",
        "role": "主角"
      },
      "sourceText": "原文片段...",
      "confidence": 0.95
    }
  ]
}
```
```

#### 3.5.2 场景摘要生成 Prompt 模板

```
你是一个专业的小说编辑助手。请为以下场景文本生成一份简洁的上下文摘要，用于帮助 AI 在后续章节中保持故事连贯性。

## 摘要要求

1. 用 150-300 字概括场景的核心内容
2. 必须包含以下要素（如果场景中存在）：
   - 出场角色及其行为
   - 场景发生的地点
   - 关键事件和转折
   - 角色情感状态的变化
   - 新揭示的信息或伏笔
   - 时间线推进情况
3. 使用第三人称客观叙述
4. 不要添加评论或分析，只陈述事实

## 场景信息

- 故事标题：{storyTitle}
- 章节：第{chapterIndex}章
- 场景序号：{sceneIndex}
- 前一场景摘要：{previousSummary}

## 场景文本

{sceneText}

## 输出格式

请直接返回摘要文本，不要包含标题或格式标记。同时在末尾用 JSON 格式附加结构化信息：

---METADATA---
{
  "activeCharacters": ["角色1", "角色2"],
  "activeLocations": ["地点1"],
  "timelinePosition": "时间描述",
  "emotionalTone": "情感基调",
  "keyEvents": ["事件1", "事件2"]
}
```

<!-- APPEND_MARKER_17 -->
